<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Dune::XT::Common Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00198.html">Dune</a></li><li class="navelem"><a class="el" href="a00200.html">XT</a></li><li class="navelem"><a class="el" href="a00201.html">Common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dune::XT::Common Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00204"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Exceptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">FloatCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00208"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">TupleProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">Colors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to define color constants that can be used to print colored text in an output stream.  <a href="a00014.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">StreamModifiers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">ConvergenceStudy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">FixedMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom iterator for <a class="el" href="a00049.html">FixedMap</a>  <a href="a00050.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">ConstFixedMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom const iterator for <a class="el" href="a00049.html">FixedMap</a>  <a href="a00018.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">FixedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a std::map like container that prevents map size change  <a href="a00049.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">VectorAbstraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to statically extract information of a (mathematical) vector.  <a href="a00132.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">is_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">logically and structurally this belongs in type_utils.hh, but the dependent implementation prohibits that  <a href="a00065.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">FieldMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">FieldMatrix&lt; K, 1, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">FieldVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">ValueInitFieldVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">VectorAbstraction&lt; Dune::XT::Common::FieldVector&lt; K, SIZE &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="a00132.html" title="Traits to statically extract information of a (mathematical) vector. ">VectorAbstraction</a> for <a class="el" href="a00046.html">Dune::XT::Common::FieldVector</a>.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">LocalizationStudy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">Logging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">handles all logging  <a href="a00070.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">SuspendableStrBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">FileBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">EmptyBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">TimedPrefixedStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer to be used in <a class="el" href="a00111.html" title="A std::ostream compatible stream that begins every line by printing elapsed time and prefix...">TimedPrefixedLogStream</a>.  <a href="a00112.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">LogStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">TimedPrefixedLogStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::ostream compatible stream that begins every line by printing elapsed time and prefix.  <a href="a00111.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">FileLogStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream compatible class wrapping file and console output  <a href="a00048.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">EmptyLogStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">/dev/null  <a href="a00035.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">Epsilon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">Epsilon&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">Epsilon&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">Epsilon&lt; std::string, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">AbsoluteValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">AbsoluteValue&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">Absretval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">Absretval&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">MinMaxAvg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a vector wrapper for continiously updating min,max,avg of some element type vector  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">numeric_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">numeric_limits&lt; T, typename std::enable_if&lt; std::numeric_limits&lt; T &gt;::is_specialized &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">MatrixAbstraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to statically extract the information of a (mathematical) matrix.  <a href="a00072.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">MatrixAbstraction&lt; Dune::DynamicMatrix&lt; K &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">MatrixAbstraction&lt; Dune::FieldMatrix&lt; K, N, M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">MatrixAbstraction&lt; Dune::XT::Common::FieldMatrix&lt; K, N, M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">is_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">WraparoundArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">remove_const_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">IndexSetPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition that assigns each codim-0 entity in a IndexSet a unique partition number, its index in the set.  <a href="a00057.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">ThreadManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">FallbackPerThreadValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">PrefixOutputIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">UniformDistributionSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to abstract away selecting an integer or real valued distribution.  <a href="a00120.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">UniformDistributionSelector&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">UniformDistributionSelector&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">RNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">RNG&lt; std::complex&lt; T &gt;, DistributionImp, EngineImp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">RandomStrings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00100.html">RNG</a> that represents strings of given length.  <a href="a00085.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">DefaultRNG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">defaultrng with choice of uniform distribution and stl's default random engine based on T and its <a class="el" href="a00079.html">numeric_limits</a>  <a href="a00031.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">DefaultRNG&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">DefaultRNG&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">HexToString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper struct for lexical cast  <a href="a00055.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">TimedLogManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A logging manager that provides info, debug and warning streams.  <a href="a00110.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">TimedLogging</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A logger that provides colored and prefixed streams.  <a href="a00109.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">TimingData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps name, start- and end time for one timing section  <a href="a00113.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">Timings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple inline timing class  <a href="a00114.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">ScopedTiming</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">OutputScopedTiming</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">TupleSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">split our function wrapper into sep pointers for Datawriter input  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">FullTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">Typename</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an extensible mechanism to assign "cleartext" names to types  <a href="a00116.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">is_smart_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">is_smart_ptr&lt; T, typename std::enable_if&lt; std::is_same&lt; std::unique_ptr&lt; typename T::element_type &gt;, T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">is_smart_ptr&lt; T, typename std::enable_if&lt; std::is_same&lt; std::shared_ptr&lt; typename T::element_type &gt;, T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">is_smart_ptr&lt; T, typename std::enable_if&lt; std::is_same&lt; std::weak_ptr&lt; typename T::element_type &gt;, T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">PtrCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">PtrCaller&lt; T, typename std::enable_if&lt; is_smart_ptr&lt; T &gt;::value||std::is_pointer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">underlying_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">is_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">gcc &lt; 4.8 fires a static-assert if std::hash&lt; T &gt; () isn't implemented  <a href="a00059.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">ValidatorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all Validators the idea is from dune-fem, only our class is an actual interface.  <a href="a00130.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">ValidateAny</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class usable as a default validator  <a href="a00124.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">ValidateInList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">validates arg iff in given list  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">ValidateLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate arg iff less than value, obviously  <a href="a00129.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">ValidateGreater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate arg iff greater than value, obviously  <a href="a00125.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">ValidateInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate iff not Validator(arg)  <a href="a00128.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">ValidateInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate arg iff arg  [min,max]  <a href="a00127.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">Typename&lt; ValidateAny&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">example partial specialisation  <a href="a00117.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">VectorAbstraction&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">VectorAbstraction&lt; Dune::DynamicVector&lt; K &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">VectorAbstraction&lt; Dune::FieldVector&lt; K, SIZE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">VectorAbstraction&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92b1de7ddbc33a375e56b4da930772c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92b1de7ddbc33a375e56b4da930772c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a92b1de7ddbc33a375e56b4da930772c7">PerThreadValue</a> = <a class="el" href="a00043.html">FallbackPerThreadValue</a>&lt; T &gt;</td></tr>
<tr class="separator:a92b1de7ddbc33a375e56b4da930772c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed6f5d31577b57e45f4c77e5d5ce998"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a8ed6f5d31577b57e45f4c77e5d5ce998">handler_type</a> (int)</td></tr>
<tr class="memdesc:a8ed6f5d31577b57e45f4c77e5d5ce998"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of handler functions  <a href="#a8ed6f5d31577b57e45f4c77e5d5ce998">More...</a><br/></td></tr>
<tr class="separator:a8ed6f5d31577b57e45f4c77e5d5ce998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac2e1d131ecddc7581ae53ef1579bcb51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51">LogFlags</a> { <br/>
&#160;&#160;<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a2a93839bd0775b128b176e7fc9f5f463">LOG_NONE</a> = 1, 
<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a71904eda5d7f2b01f956a0b65dfcb917">LOG_ERROR</a> = 2, 
<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a38586dd066078a9a25ed256e35a435f5">LOG_INFO</a> = 4, 
<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51ab1b746754059eaddfe504fb6440bb863">LOG_DEBUG</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a1eb1ed0500c21fd4e779c52ddc672cd2">LOG_CONSOLE</a> = 16, 
<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a2071c73dc17ef39d8a380fe184f4c86d">LOG_FILE</a> = 32, 
<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51ac944fb7820861a2f0f729ad20f280251">LOG_NEXT</a> = 64
<br/>
 }</td></tr>
<tr class="separator:ac2e1d131ecddc7581ae53ef1579bcb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1cd3a641b1ed7c2a3d472103efd79a44"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class OutputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a1cd3a641b1ed7c2a3d472103efd79a44"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a1cd3a641b1ed7c2a3d472103efd79a44">move_if</a> (InputIt first, InputIt last, OutputIt d_first, UnaryPredicate pred)</td></tr>
<tr class="memdesc:a1cd3a641b1ed7c2a3d472103efd79a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as std::copy_if, but with move  <a href="#a1cd3a641b1ed7c2a3d472103efd79a44">More...</a><br/></td></tr>
<tr class="separator:a1cd3a641b1ed7c2a3d472103efd79a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8018fbe2978d997591faf71ad0f4925b"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class SequenceType  = std::vector&lt;std::string&gt;&gt; </td></tr>
<tr class="memitem:a8018fbe2978d997591faf71ad0f4925b"><td class="memTemplItemLeft" align="right" valign="top">SequenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a8018fbe2978d997591faf71ad0f4925b">make_string_sequence</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a8018fbe2978d997591faf71ad0f4925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae410fa0bf53a8ad1599adca98dfd78a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aae410fa0bf53a8ad1599adca98dfd78a">color</a> (size_t i)</td></tr>
<tr class="memdesc:aae410fa0bf53a8ad1599adca98dfd78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a color from a 256 color map for a foreground color.  <a href="#aae410fa0bf53a8ad1599adca98dfd78a">More...</a><br/></td></tr>
<tr class="separator:aae410fa0bf53a8ad1599adca98dfd78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6bc6aa4fa5f4422bf8165e50a66ce3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <br class="typebreak"/>
std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a1e6bc6aa4fa5f4422bf8165e50a66ce3">color_map</a> ()</td></tr>
<tr class="separator:a1e6bc6aa4fa5f4422bf8165e50a66ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad677a712d326140bf7b8ee02816ac723"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ad677a712d326140bf7b8ee02816ac723">color</a> (const std::string id)</td></tr>
<tr class="separator:ad677a712d326140bf7b8ee02816ac723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e57402eb1a45afba1bebcf6559beb80"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a8e57402eb1a45afba1bebcf6559beb80">backcolor</a> (size_t i)</td></tr>
<tr class="memdesc:a8e57402eb1a45afba1bebcf6559beb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses a color from a 256 color map for a background color.  <a href="#a8e57402eb1a45afba1bebcf6559beb80">More...</a><br/></td></tr>
<tr class="separator:a8e57402eb1a45afba1bebcf6559beb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf76cf96f4447ff965affc9354cb48c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#adf76cf96f4447ff965affc9354cb48c3">template_color_chooser</a> (size_t i)</td></tr>
<tr class="separator:adf76cf96f4447ff965affc9354cb48c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74fd1ccc1f6dcc37670869d5189e7e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ab74fd1ccc1f6dcc37670869d5189e7e5">terminal_supports_color</a> ()</td></tr>
<tr class="separator:ab74fd1ccc1f6dcc37670869d5189e7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ecf3b38b7bddcb3725d7a83b9cda90"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a73ecf3b38b7bddcb3725d7a83b9cda90">highlight_template</a> (std::string str, size_t maxlevel=10000)</td></tr>
<tr class="memdesc:a73ecf3b38b7bddcb3725d7a83b9cda90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highlights templates depending on the "template"-level.  <a href="#a73ecf3b38b7bddcb3725d7a83b9cda90">More...</a><br/></td></tr>
<tr class="separator:a73ecf3b38b7bddcb3725d7a83b9cda90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28deec858d5896bacdc9278583a1c38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aa28deec858d5896bacdc9278583a1c38">highlight_string</a> (std::string str, size_t colornr=0)</td></tr>
<tr class="memdesc:aa28deec858d5896bacdc9278583a1c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function highlighting a whole string in a specified foreground color.  <a href="#aa28deec858d5896bacdc9278583a1c38">More...</a><br/></td></tr>
<tr class="separator:aa28deec858d5896bacdc9278583a1c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054723b7440cdd5a5174fde345fabef0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a054723b7440cdd5a5174fde345fabef0">highlight_search_string</a> (std::string str, std::string substr, size_t colornr=0)</td></tr>
<tr class="memdesc:a054723b7440cdd5a5174fde345fabef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highlights a substring of another string in a specified color.  <a href="#a054723b7440cdd5a5174fde345fabef0">More...</a><br/></td></tr>
<tr class="separator:a054723b7440cdd5a5174fde345fabef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45942581127492f7595007847b1a26f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ab45942581127492f7595007847b1a26f">color_string</a> (const std::string str, const std::string clr)</td></tr>
<tr class="separator:ab45942581127492f7595007847b1a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74f8dc797524b53dd8cf358905c8c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aad74f8dc797524b53dd8cf358905c8c5">color_string_red</a> (const std::string str)</td></tr>
<tr class="separator:aad74f8dc797524b53dd8cf358905c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39de49f04749418f61e080c76fac4e99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a39de49f04749418f61e080c76fac4e99">load_into_fem_parameter</a> (const Dune::ParameterTree &amp;tree, const std::string pref=&quot;&quot;)</td></tr>
<tr class="memdesc:a39de49f04749418f61e080c76fac4e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all key-value pairs from tree into fem parameter database.  <a href="#a39de49f04749418f61e080c76fac4e99">More...</a><br/></td></tr>
<tr class="separator:a39de49f04749418f61e080c76fac4e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf939f5fe71f5953c6faa4036577364"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a0bf939f5fe71f5953c6faa4036577364">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00016.html">Configuration</a> &amp;config)</td></tr>
<tr class="separator:a0bf939f5fe71f5953c6faa4036577364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faf3f0cc31d96e6a8b07672e2bff1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a3faf3f0cc31d96e6a8b07672e2bff1ab">operator==</a> (const <a class="el" href="a00016.html">Configuration</a> &amp;left, const <a class="el" href="a00016.html">Configuration</a> &amp;right)</td></tr>
<tr class="separator:a3faf3f0cc31d96e6a8b07672e2bff1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824072614e4d004562c88b0c0370e635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a824072614e4d004562c88b0c0370e635">operator!=</a> (const <a class="el" href="a00016.html">Configuration</a> &amp;left, const <a class="el" href="a00016.html">Configuration</a> &amp;right)</td></tr>
<tr class="separator:a824072614e4d004562c88b0c0370e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee31c8b706d47cb99e19d0f2540c2e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00016.html">Configuration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#acee31c8b706d47cb99e19d0f2540c2e7">Config</a> ()</td></tr>
<tr class="memdesc:acee31c8b706d47cb99e19d0f2540c2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">global <a class="el" href="a00016.html">Configuration</a> instance  <a href="#acee31c8b706d47cb99e19d0f2540c2e7">More...</a><br/></td></tr>
<tr class="separator:acee31c8b706d47cb99e19d0f2540c2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2986af33e211b303cfab272834afd1b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a2986af33e211b303cfab272834afd1b0">directory_only</a> (std::string _path)</td></tr>
<tr class="memdesc:a2986af33e211b303cfab272834afd1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">strip filename from  if present, return empty string if only filename present  <a href="#a2986af33e211b303cfab272834afd1b0">More...</a><br/></td></tr>
<tr class="separator:a2986af33e211b303cfab272834afd1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e065648e85919888e9098f269e9b0b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a54e065648e85919888e9098f269e9b0b">filename_only</a> (const std::string &amp;_path)</td></tr>
<tr class="memdesc:a54e065648e85919888e9098f269e9b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return everything after the last slash  <a href="#a54e065648e85919888e9098f269e9b0b">More...</a><br/></td></tr>
<tr class="separator:a54e065648e85919888e9098f269e9b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2322cfc02a54be4f99292967f42493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a9b2322cfc02a54be4f99292967f42493">test_create_directory</a> (const std::string _path)</td></tr>
<tr class="memdesc:a9b2322cfc02a54be4f99292967f42493"><td class="mdescLeft">&#160;</td><td class="mdescRight">may include filename, will be stripped  <a href="#a9b2322cfc02a54be4f99292967f42493">More...</a><br/></td></tr>
<tr class="separator:a9b2322cfc02a54be4f99292967f42493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae8cb511ffb51c3382ca4618ca3aa94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#adae8cb511ffb51c3382ca4618ca3aa94">touch</a> (const std::string &amp;_path)</td></tr>
<tr class="memdesc:adae8cb511ffb51c3382ca4618ca3aa94"><td class="mdescLeft">&#160;</td><td class="mdescRight">pure c++ emulation of system's touch binary  <a href="#adae8cb511ffb51c3382ca4618ca3aa94">More...</a><br/></td></tr>
<tr class="separator:adae8cb511ffb51c3382ca4618ca3aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b53ffdec58036948334e93554725377"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; boost::filesystem::ofstream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a8b53ffdec58036948334e93554725377">make_ofstream</a> (const boost::filesystem::path &amp;path, const std::ios_base::openmode mode)</td></tr>
<tr class="separator:a8b53ffdec58036948334e93554725377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8fcbc22dbd95c4787df77e2cb1dab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; boost::filesystem::ifstream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ac3b8fcbc22dbd95c4787df77e2cb1dab">make_ifstream</a> (const boost::filesystem::path &amp;path, const std::ios_base::openmode mode)</td></tr>
<tr class="separator:ac3b8fcbc22dbd95c4787df77e2cb1dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f39a6650071ad7c1c63a908ad3b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ad51f39a6650071ad7c1c63a908ad3b81">file_to_stream_filtered</a> (std::ostream &amp;stream, std::string filename, std::string filter)</td></tr>
<tr class="memdesc:ad51f39a6650071ad7c1c63a908ad3b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a file and output all lines containing filter string to a stream  <a href="#ad51f39a6650071ad7c1c63a908ad3b81">More...</a><br/></td></tr>
<tr class="separator:ad51f39a6650071ad7c1c63a908ad3b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad802869dff3066b8dff4db6b0a8d8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aad802869dff3066b8dff4db6b0a8d8c8">meminfo</a> (<a class="el" href="a00071.html">LogStream</a> &amp;stream)</td></tr>
<tr class="memdesc:aad802869dff3066b8dff4db6b0a8d8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">output programs mem usage stats by reading from /proc  <a href="#aad802869dff3066b8dff4db6b0a8d8c8">More...</a><br/></td></tr>
<tr class="separator:aad802869dff3066b8dff4db6b0a8d8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d64109047dd257a602f041d742d3864"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a8d64109047dd257a602f041d742d3864">logflags_</a> (<a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51a2a93839bd0775b128b176e7fc9f5f463">LOG_NONE</a>)</td></tr>
<tr class="separator:a8d64109047dd257a602f041d742d3864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11226556247d2a92db00d8aafaa43811"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a11226556247d2a92db00d8aafaa43811">emptyLogStream_</a> (<a class="el" href="a00201.html#a8d64109047dd257a602f041d742d3864">logflags_</a>)</td></tr>
<tr class="separator:a11226556247d2a92db00d8aafaa43811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144e40241b3574c7e24cc0494d8c66ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Logging</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a144e40241b3574c7e24cc0494d8c66ab">Logger</a> ()</td></tr>
<tr class="memdesc:a144e40241b3574c7e24cc0494d8c66ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">global <a class="el" href="a00070.html" title="handles all logging ">Logging</a> instance  <a href="#a144e40241b3574c7e24cc0494d8c66ab">More...</a><br/></td></tr>
<tr class="separator:a144e40241b3574c7e24cc0494d8c66ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0362e75a8cb2bfcbff9f03189ae96db7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0362e75a8cb2bfcbff9f03189ae96db7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00009.html">Absretval</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a0362e75a8cb2bfcbff9f03189ae96db7">abs</a> (const T &amp;val)</td></tr>
<tr class="separator:a0362e75a8cb2bfcbff9f03189ae96db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09754a0cdf797b4304cc1ab1a79428bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09754a0cdf797b4304cc1ab1a79428bd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a09754a0cdf797b4304cc1ab1a79428bd">clamp</a> (const T var, const T min, const T max)</td></tr>
<tr class="separator:a09754a0cdf797b4304cc1ab1a79428bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4622c6f243cfb492ad9e8419bcdb56be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4622c6f243cfb492ad9e8419bcdb56be"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a4622c6f243cfb492ad9e8419bcdb56be">signum</a> (T val)</td></tr>
<tr class="separator:a4622c6f243cfb492ad9e8419bcdb56be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d953bec4c507b6a7eb1df7a6cf6e4ac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2d953bec4c507b6a7eb1df7a6cf6e4ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a2d953bec4c507b6a7eb1df7a6cf6e4ac">isnan</a> (T val)</td></tr>
<tr class="memdesc:a2d953bec4c507b6a7eb1df7a6cf6e4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward to std::isnan for general types, overload for complex below  <a href="#a2d953bec4c507b6a7eb1df7a6cf6e4ac">More...</a><br/></td></tr>
<tr class="separator:a2d953bec4c507b6a7eb1df7a6cf6e4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4cbc712375c33cf1fd890e09e3f3c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7a4cbc712375c33cf1fd890e09e3f3c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a7a4cbc712375c33cf1fd890e09e3f3c1">isnan</a> (std::complex&lt; T &gt; val)</td></tr>
<tr class="memdesc:a7a4cbc712375c33cf1fd890e09e3f3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">override isnan for complex here so it doesn't bleed into the std namespace  <a href="#a7a4cbc712375c33cf1fd890e09e3f3c1">More...</a><br/></td></tr>
<tr class="separator:a7a4cbc712375c33cf1fd890e09e3f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598ba8459f2ae1d2eda4ddfbbddf333c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a598ba8459f2ae1d2eda4ddfbbddf333c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a598ba8459f2ae1d2eda4ddfbbddf333c">isinf</a> (T val)</td></tr>
<tr class="memdesc:a598ba8459f2ae1d2eda4ddfbbddf333c"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward to std::isinf for general types, overload for complex below  <a href="#a598ba8459f2ae1d2eda4ddfbbddf333c">More...</a><br/></td></tr>
<tr class="separator:a598ba8459f2ae1d2eda4ddfbbddf333c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae639924973cc3dd25d4f4260d841f3a3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae639924973cc3dd25d4f4260d841f3a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ae639924973cc3dd25d4f4260d841f3a3">isinf</a> (std::complex&lt; T &gt; val)</td></tr>
<tr class="memdesc:ae639924973cc3dd25d4f4260d841f3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">override isinf for complex here so it doesn't bleed into the std namespace  <a href="#ae639924973cc3dd25d4f4260d841f3a3">More...</a><br/></td></tr>
<tr class="separator:ae639924973cc3dd25d4f4260d841f3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c0f4f7db5ef31b6f584e0fd2ec239a"><td class="memTemplParams" colspan="2">template&lt;class MatrixType &gt; </td></tr>
<tr class="memitem:a61c0f4f7db5ef31b6f584e0fd2ec239a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00060.html">is_matrix</a><br class="typebreak"/>
&lt; MatrixType &gt;::value, <br class="typebreak"/>
MatrixType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a61c0f4f7db5ef31b6f584e0fd2ec239a">create</a> (const size_t sz, const typename <a class="el" href="a00072.html">MatrixAbstraction</a>&lt; MatrixType &gt;::S &amp;val)</td></tr>
<tr class="separator:a61c0f4f7db5ef31b6f584e0fd2ec239a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c008a3400d51bf0f0de9b51f7debd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aa7c008a3400d51bf0f0de9b51f7debd0">dump_environment</a> (boost::filesystem::ofstream &amp;file, std::string csv_sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:aa7c008a3400d51bf0f0de9b51f7debd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes process environment to file  <a href="#aa7c008a3400d51bf0f0de9b51f7debd0">More...</a><br/></td></tr>
<tr class="separator:aa7c008a3400d51bf0f0de9b51f7debd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f1171f0af869ec94191eec4046b959"><td class="memTemplParams" colspan="2">template&lt;class StlSequence &gt; </td></tr>
<tr class="memitem:ad0f1171f0af869ec94191eec4046b959"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ad0f1171f0af869ec94191eec4046b959">get_idx</a> (const StlSequence &amp;ct, const typename StlSequence::value_type &amp;val)</td></tr>
<tr class="memdesc:ad0f1171f0af869ec94191eec4046b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">element-index-in-container search  <a href="#ad0f1171f0af869ec94191eec4046b959">More...</a><br/></td></tr>
<tr class="separator:ad0f1171f0af869ec94191eec4046b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb168c90bfe5f1f33b88be6bbdef21c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a3eb168c90bfe5f1f33b88be6bbdef21c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a3eb168c90bfe5f1f33b88be6bbdef21c">array_length</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a3eb168c90bfe5f1f33b88be6bbdef21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type safe (this will not compile for degraded-to-pointer arrays) way of getting array length  <a href="#a3eb168c90bfe5f1f33b88be6bbdef21c">More...</a><br/></td></tr>
<tr class="separator:a3eb168c90bfe5f1f33b88be6bbdef21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c81c2f78e93769390971e259f3ab7c7"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a0c81c2f78e93769390971e259f3ab7c7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a0c81c2f78e93769390971e259f3ab7c7">make_array</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a0c81c2f78e93769390971e259f3ab7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a non-zero initialised array  <a href="#a0c81c2f78e93769390971e259f3ab7c7">More...</a><br/></td></tr>
<tr class="separator:a0c81c2f78e93769390971e259f3ab7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e90ab2eb7c057e24a043eaf37eceed"><td class="memTemplParams" colspan="2">template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a93e90ab2eb7c057e24a043eaf37eceed"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a93e90ab2eb7c057e24a043eaf37eceed">make_array</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a93e90ab2eb7c057e24a043eaf37eceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775ae8420d4cf4d5e94286e7c134403c"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename MapType &gt; </td></tr>
<tr class="memitem:a775ae8420d4cf4d5e94286e7c134403c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <br class="typebreak"/>
MapType::iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a775ae8420d4cf4d5e94286e7c134403c">map_emplace</a> (MapType &amp;map_in, Key key, T value)</td></tr>
<tr class="separator:a775ae8420d4cf4d5e94286e7c134403c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21d7a47a6f8e82d823e9c06d3160316"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename MapType &gt; </td></tr>
<tr class="memitem:ab21d7a47a6f8e82d823e9c06d3160316"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <br class="typebreak"/>
MapType::iterator, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ab21d7a47a6f8e82d823e9c06d3160316">map_emplace</a> (MapType &amp;map_in, std::piecewise_construct_t pcw, K &amp;&amp;keys, V &amp;&amp;values)</td></tr>
<tr class="separator:ab21d7a47a6f8e82d823e9c06d3160316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b628b382f714139846b5f85419b6834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html">ThreadManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a9b628b382f714139846b5f85419b6834">threadManager</a> ()</td></tr>
<tr class="memdesc:a9b628b382f714139846b5f85419b6834"><td class="mdescLeft">&#160;</td><td class="mdescRight">global singleton <a class="el" href="a00108.html">ThreadManager</a>  <a href="#a9b628b382f714139846b5f85419b6834">More...</a><br/></td></tr>
<tr class="separator:a9b628b382f714139846b5f85419b6834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7837cf7354d87702504be884e91c76fd"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a7837cf7354d87702504be884e91c76fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00065.html">is_vector</a>&lt; V &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a7837cf7354d87702504be884e91c76fd">print</a> (const V &amp;vec, const std::string name, std::ostream &amp;out, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="separator:a7837cf7354d87702504be884e91c76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfd39ad309acb7c70f69280155cfac2"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a2dfd39ad309acb7c70f69280155cfac2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00060.html">is_matrix</a>&lt; M &gt;<br class="typebreak"/>
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a2dfd39ad309acb7c70f69280155cfac2">print</a> (const M &amp;mat, const std::string name, std::ostream &amp;out, const std::string prefix=&quot;&quot;)</td></tr>
<tr class="separator:a2dfd39ad309acb7c70f69280155cfac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7261086efd006a0964e1d222412dda9"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ae7261086efd006a0964e1d222412dda9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ae7261086efd006a0964e1d222412dda9">matrix_to_gnuplot_stream</a> (const Matrix &amp;matrix, std::ostream &amp;stream)</td></tr>
<tr class="memdesc:ae7261086efd006a0964e1d222412dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">useful for visualizing sparsity patterns of matrices  <a href="#ae7261086efd006a0964e1d222412dda9">More...</a><br/></td></tr>
<tr class="separator:ae7261086efd006a0964e1d222412dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3c7639e56ffed55835f4315067af80"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a3a3c7639e56ffed55835f4315067af80">dim_to_axis_name</a> (const size_t dim, const bool capitalize=false)</td></tr>
<tr class="memdesc:a3a3c7639e56ffed55835f4315067af80"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps 1,2,3 to x,y,z / X,Y,Z  <a href="#a3a3c7639e56ffed55835f4315067af80">More...</a><br/></td></tr>
<tr class="separator:a3a3c7639e56ffed55835f4315067af80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9f619a2046fc67c6a9dba74c7ce858"><td class="memTemplParams" colspan="2">template&lt;class T , class sequence  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4e9f619a2046fc67c6a9dba74c7ce858"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_enum<br class="typebreak"/>
&lt; T &gt;::value, sequence &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range</a> (const T start, const T end, const T increment=<a class="el" href="a00037.html">Epsilon</a>&lt; T &gt;::value)</td></tr>
<tr class="memdesc:a4e9f619a2046fc67c6a9dba74c7ce858"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector with values in [start : increment : end)  <a href="#a4e9f619a2046fc67c6a9dba74c7ce858">More...</a><br/></td></tr>
<tr class="separator:a4e9f619a2046fc67c6a9dba74c7ce858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523668e8a8d31bc2583ea3a4f34f9369"><td class="memTemplParams" colspan="2">template&lt;class T , class sequence  = std::vector&lt;typename Absretval&lt;T&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a523668e8a8d31bc2583ea3a4f34f9369"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_enum<br class="typebreak"/>
&lt; T &gt;::value, sequence &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a523668e8a8d31bc2583ea3a4f34f9369">value_range</a> (const T start, const T end, const typename <a class="el" href="a00009.html">Absretval</a>&lt; T &gt;::type increment=<a class="el" href="a00037.html">Epsilon</a>&lt; typename <a class="el" href="a00009.html">Absretval</a>&lt; T &gt;::type &gt;::value)</td></tr>
<tr class="memdesc:a523668e8a8d31bc2583ea3a4f34f9369"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature for enumeration Types T  <a href="#a523668e8a8d31bc2583ea3a4f34f9369">More...</a><br/></td></tr>
<tr class="separator:a523668e8a8d31bc2583ea3a4f34f9369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361d6033fb7c152dff9062ee6a67e9e0"><td class="memTemplParams" colspan="2">template&lt;class T , class sequence  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a361d6033fb7c152dff9062ee6a67e9e0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_enum<br class="typebreak"/>
&lt; T &gt;::value, sequence &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a361d6033fb7c152dff9062ee6a67e9e0">value_range</a> (const T end)</td></tr>
<tr class="memdesc:a361d6033fb7c152dff9062ee6a67e9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector with values in [0 : Epsilon&lt;T&gt; : end)  <a href="#a361d6033fb7c152dff9062ee6a67e9e0">More...</a><br/></td></tr>
<tr class="separator:a361d6033fb7c152dff9062ee6a67e9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4608b4bd0f42640c3069f22fffa7696e"><td class="memTemplParams" colspan="2">template&lt;class T , class sequence  = std::vector&lt;typename Absretval&lt;T&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a4608b4bd0f42640c3069f22fffa7696e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_enum<br class="typebreak"/>
&lt; T &gt;::value, sequence &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a4608b4bd0f42640c3069f22fffa7696e">value_range</a> (const T end)</td></tr>
<tr class="memdesc:a4608b4bd0f42640c3069f22fffa7696e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector with values in [0 : Epsilon&lt;T&gt; : end)  <a href="#a4608b4bd0f42640c3069f22fffa7696e">More...</a><br/></td></tr>
<tr class="separator:a4608b4bd0f42640c3069f22fffa7696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0184fc9212146d42c91446567d99d4d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a0184fc9212146d42c91446567d99d4d2">reset_signal</a> (int signal)</td></tr>
<tr class="memdesc:a0184fc9212146d42c91446567d99d4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset given signal to default handler  <a href="#a0184fc9212146d42c91446567d99d4d2">More...</a><br/></td></tr>
<tr class="separator:a0184fc9212146d42c91446567d99d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20855700748560f9698f4f5a0dee310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#aa20855700748560f9698f4f5a0dee310">handle_interrupt</a> (int signal)</td></tr>
<tr class="memdesc:aa20855700748560f9698f4f5a0dee310"><td class="mdescLeft">&#160;</td><td class="mdescRight">example signal handler  <a href="#aa20855700748560f9698f4f5a0dee310">More...</a><br/></td></tr>
<tr class="separator:aa20855700748560f9698f4f5a0dee310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24391792725f6d1e7d2f53ee88fdd2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a24391792725f6d1e7d2f53ee88fdd2da">install_signal_handler</a> (int signal, <a class="el" href="a00201.html#a8ed6f5d31577b57e45f4c77e5d5ce998">handler_type</a> handler)</td></tr>
<tr class="memdesc:a24391792725f6d1e7d2f53ee88fdd2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">calling this from your main() will install handler as callback when signal is received  <a href="#a24391792725f6d1e7d2f53ee88fdd2da">More...</a><br/></td></tr>
<tr class="separator:a24391792725f6d1e7d2f53ee88fdd2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c12845cd6b781efc6d622bbab090164"><td class="memTemplParams" colspan="2">template&lt;class T  = std::string&gt; </td></tr>
<tr class="memitem:a2c12845cd6b781efc6d622bbab090164"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a2c12845cd6b781efc6d622bbab090164">tokenize</a> (const std::string &amp;msg, const std::string &amp;separators, const boost::algorithm::token_compress_mode_type mode=boost::algorithm::token_compress_off)</td></tr>
<tr class="memdesc:a2c12845cd6b781efc6d622bbab090164"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper around boost::algorithm::split to split one string into a vector of strings  <a href="#a2c12845cd6b781efc6d622bbab090164">More...</a><br/></td></tr>
<tr class="separator:a2c12845cd6b781efc6d622bbab090164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fd1d93d179c6d32133eeaa7117e29a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a42fd1d93d179c6d32133eeaa7117e29a"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a42fd1d93d179c6d32133eeaa7117e29a">from_string</a> (std::string ss, const size_t size=0, const size_t cols=0)</td></tr>
<tr class="memdesc:a42fd1d93d179c6d32133eeaa7117e29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an object from a string.  <a href="#a42fd1d93d179c6d32133eeaa7117e29a">More...</a><br/></td></tr>
<tr class="separator:a42fd1d93d179c6d32133eeaa7117e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ead21a43b9ca17c453748f5a6aa82b1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ead21a43b9ca17c453748f5a6aa82b1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string</a> (const T &amp;ss, const size_t precision=<a class="el" href="a00201.html#abca605b4ce1c01eaf2b32bd16ffd979f">default_to_string_precision</a>)</td></tr>
<tr class="memdesc:a5ead21a43b9ca17c453748f5a6aa82b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an object to string.  <a href="#a5ead21a43b9ca17c453748f5a6aa82b1">More...</a><br/></td></tr>
<tr class="separator:a5ead21a43b9ca17c453748f5a6aa82b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7583afa226b29992e5c333ade96456ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7583afa226b29992e5c333ade96456ab"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a7583afa226b29992e5c333ade96456ab">whitespaceify</a> (const T &amp;t, const char whitespace= ' ')</td></tr>
<tr class="memdesc:a7583afa226b29992e5c333ade96456ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string of lengths t' whitespace (or whitespace chars).  <a href="#a7583afa226b29992e5c333ade96456ab">More...</a><br/></td></tr>
<tr class="separator:a7583afa226b29992e5c333ade96456ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98cafbf2fb3cb7229138f88c121f366"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad98cafbf2fb3cb7229138f88c121f366"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ad98cafbf2fb3cb7229138f88c121f366">tokenize</a> (const std::string &amp;msg, const std::string &amp;separators, const boost::algorithm::token_compress_mode_type mode)</td></tr>
<tr class="separator:ad98cafbf2fb3cb7229138f88c121f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caf0837c4f7fedc89feadaeaf4cb2ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a8caf0837c4f7fedc89feadaeaf4cb2ee">stringFromTime</a> (time_t cur_time=time(NULL))</td></tr>
<tr class="memdesc:a8caf0837c4f7fedc89feadaeaf4cb2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns string with local time in current locale's format  <a href="#a8caf0837c4f7fedc89feadaeaf4cb2ee">More...</a><br/></td></tr>
<tr class="separator:a8caf0837c4f7fedc89feadaeaf4cb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc7158ab050a018724ea5291b21fe78"><td class="memItemLeft" align="right" valign="top">static char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a9dc7158ab050a018724ea5291b21fe78">vector_to_main_args</a> (const std::vector&lt; std::string &gt; &amp;args)</td></tr>
<tr class="separator:a9dc7158ab050a018724ea5291b21fe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a23faeaa700b32a44d1f81a91ba1de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html">TimedLogging</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a> ()</td></tr>
<tr class="memdesc:a6a23faeaa700b32a44d1f81a91ba1de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global instance of the timed logger.  <a href="#a6a23faeaa700b32a44d1f81a91ba1de6">More...</a><br/></td></tr>
<tr class="separator:a6a23faeaa700b32a44d1f81a91ba1de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff4de6a6658c7f9938e6cd88ecd0792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00114.html">Timings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a9ff4de6a6658c7f9938e6cd88ecd0792">timings</a> ()</td></tr>
<tr class="memdesc:a9ff4de6a6658c7f9938e6cd88ecd0792"><td class="mdescLeft">&#160;</td><td class="mdescRight">XT::Profiler global instance.  <a href="#a9ff4de6a6658c7f9938e6cd88ecd0792">More...</a><br/></td></tr>
<tr class="separator:a9ff4de6a6658c7f9938e6cd88ecd0792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14382dabffb4e49c3bedf0dfdc93ad91"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a14382dabffb4e49c3bedf0dfdc93ad91">demangle_typename</a> (const std::string &amp;mangled_name)</td></tr>
<tr class="separator:a14382dabffb4e49c3bedf0dfdc93ad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996fa6182228426117cc70262dfed72b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a996fa6182228426117cc70262dfed72b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a996fa6182228426117cc70262dfed72b">demangled_type_id</a> (T &amp;obj)</td></tr>
<tr class="memdesc:a996fa6182228426117cc70262dfed72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">demangles typeid  <a href="#a996fa6182228426117cc70262dfed72b">More...</a><br/></td></tr>
<tr class="separator:a996fa6182228426117cc70262dfed72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b36372dfa9b56f663819e48960ff0d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a66b36372dfa9b56f663819e48960ff0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a66b36372dfa9b56f663819e48960ff0d">real_type_id</a> (T &amp;obj, std::string name=&quot;&quot;, size_t maxlevel=10000)</td></tr>
<tr class="memdesc:a66b36372dfa9b56f663819e48960ff0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create output for demangled typeid  <a href="#a66b36372dfa9b56f663819e48960ff0d">More...</a><br/></td></tr>
<tr class="separator:a66b36372dfa9b56f663819e48960ff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffd7229b91118bcb696c36041acc0f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9ffd7229b91118bcb696c36041acc0f8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a9ffd7229b91118bcb696c36041acc0f8">get_typename</a> (const T &amp;)</td></tr>
<tr class="separator:a9ffd7229b91118bcb696c36041acc0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6d62fd1374d95374855c6aadd6303"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a93b6d62fd1374d95374855c6aadd6303">INVERSE_VALIDATE</a> (ValidateNone, <a class="el" href="a00124.html">ValidateAny</a>)</td></tr>
<tr class="separator:a93b6d62fd1374d95374855c6aadd6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57621222800be109d15c23245087aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#ae57621222800be109d15c23245087aac">INVERSE_VALIDATE</a> (ValidateGreaterOrEqual, <a class="el" href="a00129.html">ValidateLess</a>)</td></tr>
<tr class="separator:ae57621222800be109d15c23245087aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737408d5307d767a9e9e7b0c3f05e7a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#a737408d5307d767a9e9e7b0c3f05e7a0">INVERSE_VALIDATE</a> (ValidateNotLess, <a class="el" href="a00129.html">ValidateLess</a>)</td></tr>
<tr class="separator:a737408d5307d767a9e9e7b0c3f05e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca4ccf1aef04e57c7de6576c9c4342b"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a8ca4ccf1aef04e57c7de6576c9c4342b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00065.html">is_vector</a><br class="typebreak"/>
&lt; VectorType &gt;::value, <br class="typebreak"/>
VectorType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a8ca4ccf1aef04e57c7de6576c9c4342b">create</a> (const size_t sz, const typename <a class="el" href="a00132.html">VectorAbstraction</a>&lt; VectorType &gt;::S &amp;val=typename <a class="el" href="a00132.html">VectorAbstraction</a>&lt; VectorType &gt;::S(0))</td></tr>
<tr class="separator:a8ca4ccf1aef04e57c7de6576c9c4342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997600a1036079984cf039bb55990eb6"><td class="memTemplParams" colspan="2">template&lt;class T , class SR &gt; </td></tr>
<tr class="memitem:a997600a1036079984cf039bb55990eb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; is_complex&lt; T &gt;<br class="typebreak"/>
::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a997600a1036079984cf039bb55990eb6">create</a> (const size_t, const SR &amp;val=typename <a class="el" href="a00132.html">VectorAbstraction</a>&lt; T &gt;::R(0))</td></tr>
<tr class="separator:a997600a1036079984cf039bb55990eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e31be7c9d617afd3c5e4a3d652598bc"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a1e31be7c9d617afd3c5e4a3d652598bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_arithmetic<br class="typebreak"/>
&lt; VectorType &gt;::value, <br class="typebreak"/>
VectorType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#a1e31be7c9d617afd3c5e4a3d652598bc">create</a> (const size_t, const typename <a class="el" href="a00132.html">VectorAbstraction</a>&lt; VectorType &gt;::S &amp;val=typename <a class="el" href="a00132.html">VectorAbstraction</a>&lt; VectorType &gt;::S(0))</td></tr>
<tr class="separator:a1e31be7c9d617afd3c5e4a3d652598bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abca605b4ce1c01eaf2b32bd16ffd979f"><td class="memItemLeft" align="right" valign="top">static constexpr const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html#abca605b4ce1c01eaf2b32bd16ffd979f">default_to_string_precision</a> = 6u</td></tr>
<tr class="separator:abca605b4ce1c01eaf2b32bd16ffd979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8ed6f5d31577b57e45f4c77e5d5ce998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void Dune::XT::Common::handler_type(int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of handler functions </p>

</div>
</div>
<a class="anchor" id="a92b1de7ddbc33a375e56b4da930772c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00201.html#a92b1de7ddbc33a375e56b4da930772c7">Dune::XT::Common::PerThreadValue</a> = typedef <a class="el" href="a00043.html">FallbackPerThreadValue</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00201.html#ac2e1d131ecddc7581ae53ef1579bcb51">Dune::XT::Common::LogFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51a2a93839bd0775b128b176e7fc9f5f463"></a>LOG_NONE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51a71904eda5d7f2b01f956a0b65dfcb917"></a>LOG_ERROR</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51a38586dd066078a9a25ed256e35a435f5"></a>LOG_INFO</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51ab1b746754059eaddfe504fb6440bb863"></a>LOG_DEBUG</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51a1eb1ed0500c21fd4e779c52ddc672cd2"></a>LOG_CONSOLE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51a2071c73dc17ef39d8a380fe184f4c86d"></a>LOG_FILE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac2e1d131ecddc7581ae53ef1579bcb51ac944fb7820861a2f0f729ad20f280251"></a>LOG_NEXT</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0362e75a8cb2bfcbff9f03189ae96db7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00009.html">Absretval</a>&lt;T&gt;::type Dune::XT::Common::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00007.html#ae7533a6e43ef6b46f2a6892160754c3a">Dune::XT::Common::AbsoluteValue&lt; T, isUnsigned &gt;::result()</a>.</p>

<p>Referenced by <a class="el" href="a00206.html#a1091613de78316393d55a8aef80bb858">Dune::XT::Common::FloatCmp::internal::float_cmp_eq()</a>, <a class="el" href="a00007.html#ae7533a6e43ef6b46f2a6892160754c3a">Dune::XT::Common::AbsoluteValue&lt; T, isUnsigned &gt;::result()</a>, and <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a3eb168c90bfe5f1f33b88be6bbdef21c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Dune::XT::Common::array_length </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type safe (this will not compile for degraded-to-pointer arrays) way of getting array length </p>

</div>
</div>
<a class="anchor" id="a8e57402eb1a45afba1bebcf6559beb80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::backcolor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses a color from a 256 color map for a background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The color number between 0 and 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing a color code. </dd></dl>

<p>References <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a09754a0cdf797b4304cc1ab1a79428bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Dune::XT::Common::clamp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>var bounded in [min, max] </dd></dl>

</div>
</div>
<a class="anchor" id="aae410fa0bf53a8ad1599adca98dfd78a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::color </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chooses a color from a 256 color map for a foreground color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The color number between 0 and 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing a color code. </dd></dl>

<p>References <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ad677a712d326140bf7b8ee02816ac723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::color </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a1e6bc6aa4fa5f4422bf8165e50a66ce3">color_map()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e6bc6aa4fa5f4422bf8165e50a66ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; &amp; Dune::XT::Common::color_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00014.html#a7e8ef6ad14144a2a8de3401f9318ea6a">Dune::XT::Common::Colors::black</a>, <a class="el" href="a00014.html#aaa1d1ca28af73c096778b2feceab7ce1">Dune::XT::Common::Colors::blue</a>, <a class="el" href="a00014.html#aef35444d2329ad512308433115453b91">Dune::XT::Common::Colors::brown</a>, <a class="el" href="a00014.html#a88212df4692b27bda37bdbd3de937ec6">Dune::XT::Common::Colors::cyan</a>, <a class="el" href="a00014.html#a237a21c1aaa2e857186a8d8565d9f0de">Dune::XT::Common::Colors::darkgray</a>, <a class="el" href="a00014.html#a74d3963ae2bebaa8f694bb09bb4e8f20">Dune::XT::Common::Colors::green</a>, <a class="el" href="a00014.html#a0d17c04c2a3606773470499daab99c1b">Dune::XT::Common::Colors::lightblue</a>, <a class="el" href="a00014.html#a440f64a49fa170478a887274fa1ba0cc">Dune::XT::Common::Colors::lightcyan</a>, <a class="el" href="a00014.html#af992dfe3b49bd7da185c151569280217">Dune::XT::Common::Colors::lightgray</a>, <a class="el" href="a00014.html#ac9215b3535ed9ba8cbc81225643d9e85">Dune::XT::Common::Colors::lightgreen</a>, <a class="el" href="a00014.html#ae6d70ebc297c832a6e946af2abdbc425">Dune::XT::Common::Colors::lightpurple</a>, <a class="el" href="a00014.html#ae371fd939ff99ffadbb39570c8635f41">Dune::XT::Common::Colors::lightred</a>, <a class="el" href="a00014.html#aaf0d518aa376ea6e6c21bbf042975adb">Dune::XT::Common::Colors::purple</a>, <a class="el" href="a00014.html#adc1452f4fd998895c658d516706f06d0">Dune::XT::Common::Colors::red</a>, <a class="el" href="a00014.html#a9391dc8e3d07e53a1648ea94f31393f7">Dune::XT::Common::Colors::white</a>, and <a class="el" href="a00014.html#a22c388afa76cb230c77cf50d1a3f67d1">Dune::XT::Common::Colors::yellow</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#ad677a712d326140bf7b8ee02816ac723">color()</a>.</p>

</div>
</div>
<a class="anchor" id="ab45942581127492f7595007847b1a26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::color_string </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>clr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00105.html#a9aa90d56ee2cb161ceb03e87b4c6621d">Dune::XT::Common::StreamModifiers::normal</a>, and <a class="el" href="a00201.html#ab74fd1ccc1f6dcc37670869d5189e7e5">terminal_supports_color()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#aad74f8dc797524b53dd8cf358905c8c5">color_string_red()</a>, and <a class="el" href="a00019.html#ac152d2a97d09610f6bf5fbabddaee084">Dune::XT::Common::ConvergenceStudy::run()</a>.</p>

</div>
</div>
<a class="anchor" id="aad74f8dc797524b53dd8cf358905c8c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::color_string_red </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#ab45942581127492f7595007847b1a26f">color_string()</a>, and <a class="el" href="a00014.html#adc1452f4fd998895c658d516706f06d0">Dune::XT::Common::Colors::red</a>.</p>

</div>
</div>
<a class="anchor" id="acee31c8b706d47cb99e19d0f2540c2e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html">Configuration</a>&amp; Dune::XT::Common::Config </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global <a class="el" href="a00016.html">Configuration</a> instance </p>

</div>
</div>
<a class="anchor" id="a8ca4ccf1aef04e57c7de6576c9c4342b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00065.html">is_vector</a>&lt;VectorType&gt;::value, VectorType&gt;::type Dune::XT::Common::create </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename VectorAbstraction&lt; VectorType &gt;::S &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>typename&#160;VectorAbstraction&lt;VectorType&gt;::S(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00132.html#a9c37b22ea3a0eb9a7226338beb7a493e">Dune::XT::Common::VectorAbstraction&lt; VecType &gt;::create()</a>.</p>

</div>
</div>
<a class="anchor" id="a997600a1036079984cf039bb55990eb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class SR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;is_complex&lt;T&gt;::value, T&gt;::type Dune::XT::Common::create </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SR &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>typename&#160;VectorAbstraction&lt;T&gt;::R(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00132.html#a9c37b22ea3a0eb9a7226338beb7a493e">Dune::XT::Common::VectorAbstraction&lt; VecType &gt;::create()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e31be7c9d617afd3c5e4a3d652598bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;VectorType&gt;::value, VectorType&gt;::type Dune::XT::Common::create </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename VectorAbstraction&lt; VectorType &gt;::S &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>typename&#160;VectorAbstraction&lt;VectorType&gt;::S(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a61c0f4f7db5ef31b6f584e0fd2ec239a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00060.html">is_matrix</a>&lt;MatrixType&gt;::value, MatrixType&gt;::type Dune::XT::Common::create </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MatrixAbstraction&lt; MatrixType &gt;::S &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00072.html#a9213886684c8268c5ef9bef622339183">Dune::XT::Common::MatrixAbstraction&lt; MatType &gt;::create()</a>.</p>

</div>
</div>
<a class="anchor" id="a14382dabffb4e49c3bedf0dfdc93ad91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::demangle_typename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mangled_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00201.html#a996fa6182228426117cc70262dfed72b">demangled_type_id()</a>, and <a class="el" href="a00116.html#a183b823fb449bb04e2726204671b1bff">Dune::XT::Common::Typename&lt; T &gt;::value()</a>.</p>

</div>
</div>
<a class="anchor" id="a996fa6182228426117cc70262dfed72b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::demangled_type_id </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>demangles typeid </p>

<p>References <a class="el" href="a00201.html#a14382dabffb4e49c3bedf0dfdc93ad91">demangle_typename()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a66b36372dfa9b56f663819e48960ff0d">real_type_id()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a3c7639e56ffed55835f4315067af80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::dim_to_axis_name </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>capitalize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps 1,2,3 to x,y,z / X,Y,Z </p>

</div>
</div>
<a class="anchor" id="a2986af33e211b303cfab272834afd1b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::directory_only </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>strip filename from  if present, return empty string if only filename present </p>

<p>Referenced by <a class="el" href="a00016.html#a70c1a32c61a6601a09ee267e63833e14">Dune::XT::Common::Configuration::set_log_on_exit()</a>, <a class="el" href="a00016.html#a344eb054010b511b60eb9fda8724b8e5">Dune::XT::Common::Configuration::set_logfile()</a>, <a class="el" href="a00201.html#a9b2322cfc02a54be4f99292967f42493">test_create_directory()</a>, and <a class="el" href="a00016.html#a440a109eff1d08ca77f83c806ba44a71">Dune::XT::Common::Configuration::~Configuration()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7c008a3400d51bf0f0de9b51f7debd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::dump_environment </td>
          <td>(</td>
          <td class="paramtype">boost::filesystem::ofstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>csv_sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes process environment to file </p>

<p>References <a class="el" href="a00175.html#aa006daaf11f1e2e45a6ababaf463212b">environ</a>, and <a class="el" href="a00201.html#a2c12845cd6b781efc6d622bbab090164">tokenize()</a>.</p>

</div>
</div>
<a class="anchor" id="a11226556247d2a92db00d8aafaa43811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::XT::Common::emptyLogStream_ </td>
          <td>(</td>
          <td class="paramtype">logflags_&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a8d64109047dd257a602f041d742d3864">logflags_()</a>.</p>

</div>
</div>
<a class="anchor" id="ad51f39a6650071ad7c1c63a908ad3b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::file_to_stream_filtered </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a file and output all lines containing filter string to a stream </p>

<p>Referenced by <a class="el" href="a00201.html#aad802869dff3066b8dff4db6b0a8d8c8">meminfo()</a>.</p>

</div>
</div>
<a class="anchor" id="a54e065648e85919888e9098f269e9b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::filename_only </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return everything after the last slash </p>

</div>
</div>
<a class="anchor" id="a42fd1d93d179c6d32133eeaa7117e29a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T Dune::XT::Common::from_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an object from a string. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00207.html#ae6484114ea5e66164dc8fdc7d223bde0">internal::from_string</a> for implementations </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>string to read from </td></tr>
    <tr><td class="paramname">size</td><td>Determines the size of the returning container (size if T is a vector type, rows if T is a matrix type, ignored if T is a scalar type; 0 means automatic). </td></tr>
    <tr><td class="paramname">cols</td><td>Determines the number of columns of the returning matrix if T is a matrix type (0 means automatic; ignored if T is a vector or scalar type). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0f1171f0af869ec94191eec4046b959"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StlSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dune::XT::Common::get_idx </td>
          <td>(</td>
          <td class="paramtype">const StlSequence &amp;&#160;</td>
          <td class="paramname"><em>ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename StlSequence::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element-index-in-container search </p>

</div>
</div>
<a class="anchor" id="a9ffd7229b91118bcb696c36041acc0f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::get_typename </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00116.html#a183b823fb449bb04e2726204671b1bff">Dune::XT::Common::Typename&lt; T &gt;::value()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a93e90ab2eb7c057e24a043eaf37eceed">make_array()</a>.</p>

</div>
</div>
<a class="anchor" id="aa20855700748560f9698f4f5a0dee310"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::handle_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>example signal handler </p>

<p>References <a class="el" href="a00167.html#a90779234ca3f3cbb64b044a00272eecb">DXTC_LOG_INFO</a>, <a class="el" href="a00201.html#a0184fc9212146d42c91446567d99d4d2">reset_signal()</a>, and <a class="el" href="a00201.html#a8caf0837c4f7fedc89feadaeaf4cb2ee">stringFromTime()</a>.</p>

</div>
</div>
<a class="anchor" id="a054723b7440cdd5a5174fde345fabef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::highlight_search_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>substr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>colornr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highlights a substring of another string in a specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string where you want to highlight substrings. </td></tr>
    <tr><td class="paramname">substr</td><td>The sub string you want to highlight in str. </td></tr>
    <tr><td class="paramname">colornr</td><td>A color number from a 256 color map between 0 and 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highlighted string. </dd></dl>

<p>References <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="aa28deec858d5896bacdc9278583a1c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::highlight_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>colornr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function highlighting a whole string in a specified foreground color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string you want to highlight. </td></tr>
    <tr><td class="paramname">colornr</td><td>A color number from a 256 color map between 0 and 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highlighted string. </dd></dl>

<p>References <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a73ecf3b38b7bddcb3725d7a83b9cda90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::highlight_template </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlevel</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highlights templates depending on the "template"-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string containing the template string </td></tr>
    <tr><td class="paramname">maxlevel</td><td>The maximal template-level the string is reduced to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A colored template string. </dd></dl>

<p>References <a class="el" href="a00201.html#adf76cf96f4447ff965affc9354cb48c3">template_color_chooser()</a>, and <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a66b36372dfa9b56f663819e48960ff0d">real_type_id()</a>.</p>

</div>
</div>
<a class="anchor" id="a24391792725f6d1e7d2f53ee88fdd2da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::install_signal_handler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">handler_type&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calling this from your main() will install handler as callback when signal is received </p>

</div>
</div>
<a class="anchor" id="a93b6d62fd1374d95374855c6aadd6303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::XT::Common::INVERSE_VALIDATE </td>
          <td>(</td>
          <td class="paramtype">ValidateNone&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidateAny&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae57621222800be109d15c23245087aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::XT::Common::INVERSE_VALIDATE </td>
          <td>(</td>
          <td class="paramtype">ValidateGreaterOrEqual&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidateLess&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a737408d5307d767a9e9e7b0c3f05e7a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::XT::Common::INVERSE_VALIDATE </td>
          <td>(</td>
          <td class="paramtype">ValidateNotLess&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidateLess&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a598ba8459f2ae1d2eda4ddfbbddf333c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::isinf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forward to std::isinf for general types, overload for complex below </p>

<p>References <a class="el" href="a00201.html#ae639924973cc3dd25d4f4260d841f3a3">isinf()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#ae639924973cc3dd25d4f4260d841f3a3">isinf()</a>.</p>

</div>
</div>
<a class="anchor" id="ae639924973cc3dd25d4f4260d841f3a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::isinf </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>override isinf for complex here so it doesn't bleed into the std namespace </p>

<p>References <a class="el" href="a00201.html#a598ba8459f2ae1d2eda4ddfbbddf333c">isinf()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a598ba8459f2ae1d2eda4ddfbbddf333c">isinf()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d953bec4c507b6a7eb1df7a6cf6e4ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::isnan </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>forward to std::isnan for general types, overload for complex below </p>

<p>References <a class="el" href="a00201.html#a7a4cbc712375c33cf1fd890e09e3f3c1">isnan()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a7a4cbc712375c33cf1fd890e09e3f3c1">isnan()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a4cbc712375c33cf1fd890e09e3f3c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::isnan </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>override isnan for complex here so it doesn't bleed into the std namespace </p>

<p>References <a class="el" href="a00201.html#a2d953bec4c507b6a7eb1df7a6cf6e4ac">isnan()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a2d953bec4c507b6a7eb1df7a6cf6e4ac">isnan()</a>.</p>

</div>
</div>
<a class="anchor" id="a39de49f04749418f61e080c76fac4e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::load_into_fem_parameter </td>
          <td>(</td>
          <td class="paramtype">const Dune::ParameterTree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>pref</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all key-value pairs from tree into fem parameter database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>ParameterTree to get values from. </td></tr>
    <tr><td class="paramname">pref</td><td>Prefix that is added to each key and subkey (like this: pref.key), default is "". </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="a00016.html#a9849dbd11b9fe134d85c84227f4216ce">Dune::XT::Common::Configuration::read_command_line()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d64109047dd257a602f041d742d3864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::XT::Common::logflags_ </td>
          <td>(</td>
          <td class="paramtype">LOG_NONE&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00070.html#abdd3668ace17b4ee6ba32483705bdd38">Dune::XT::Common::Logging::create()</a>, and <a class="el" href="a00201.html#a11226556247d2a92db00d8aafaa43811">emptyLogStream_()</a>.</p>

</div>
</div>
<a class="anchor" id="a144e40241b3574c7e24cc0494d8c66ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00070.html">Logging</a> &amp; Dune::XT::Common::Logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global <a class="el" href="a00070.html" title="handles all logging ">Logging</a> instance </p>

</div>
</div>
<a class="anchor" id="a0c81c2f78e93769390971e259f3ab7c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, N&gt; Dune::XT::Common::make_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a non-zero initialised array </p>

</div>
</div>
<a class="anchor" id="a93e90ab2eb7c057e24a043eaf37eceed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, N&gt; Dune::XT::Common::make_array </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00153.html#ad7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>, and <a class="el" href="a00201.html#a9ffd7229b91118bcb696c36041acc0f8">get_typename()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b8fcbc22dbd95c4787df77e2cb1dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; boost::filesystem::ifstream &gt; Dune::XT::Common::make_ifstream </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a9b2322cfc02a54be4f99292967f42493">test_create_directory()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b53ffdec58036948334e93554725377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; boost::filesystem::ofstream &gt; Dune::XT::Common::make_ofstream </td>
          <td>(</td>
          <td class="paramtype">const boost::filesystem::path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a9b2322cfc02a54be4f99292967f42493">test_create_directory()</a>.</p>

<p>Referenced by <a class="el" href="a00016.html#a440a109eff1d08ca77f83c806ba44a71">Dune::XT::Common::Configuration::~Configuration()</a>.</p>

</div>
</div>
<a class="anchor" id="a8018fbe2978d997591faf71ad0f4925b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class SequenceType  = std::vector&lt;std::string&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SequenceType Dune::XT::Common::make_string_sequence </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a775ae8420d4cf4d5e94286e7c134403c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename MapType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename MapType::iterator, bool&gt; Dune::XT::Common::map_emplace </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>abstraction for stdlibs w/o map.emplace This isn't covering the full emplace spec, and the piecewise case potentially improper, but we only need this in an Intel MIC setup with weird lib versioning. Normally we'd depend on the full gcc 4.8 stack atm and do not use the insert fallback </p>

<p>References <a class="el" href="a00167.html#ab9bc0d9a03c769f1876c6c0548df1309">DXTC_LOG_DEBUG_0</a>.</p>

</div>
</div>
<a class="anchor" id="ab21d7a47a6f8e82d823e9c06d3160316"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename MapType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename MapType::iterator, bool&gt; Dune::XT::Common::map_emplace </td>
          <td>(</td>
          <td class="paramtype">MapType &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::piecewise_construct_t&#160;</td>
          <td class="paramname"><em>pcw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00167.html#ab9bc0d9a03c769f1876c6c0548df1309">DXTC_LOG_DEBUG_0</a>.</p>

</div>
</div>
<a class="anchor" id="ae7261086efd006a0964e1d222412dda9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::matrix_to_gnuplot_stream </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>useful for visualizing sparsity patterns of matrices </p>

<p>References <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="aad802869dff3066b8dff4db6b0a8d8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::meminfo </td>
          <td>(</td>
          <td class="paramtype">LogStream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output programs mem usage stats by reading from /proc </p>

<p>References <a class="el" href="a00201.html#ad51f39a6650071ad7c1c63a908ad3b81">file_to_stream_filtered()</a>, and <a class="el" href="a00071.html#ab1ed6f48e7f7a3ec3d40a93bb14c74dc">Dune::XT::Common::LogStream::resume()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cd3a641b1ed7c2a3d472103efd79a44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class OutputIt , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIt Dune::XT::Common::move_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as std::copy_if, but with move </p>

</div>
</div>
<a class="anchor" id="a824072614e4d004562c88b0c0370e635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Configuration &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Configuration &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0bf939f5fe71f5953c6faa4036577364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Dune::XT::Common::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Configuration &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00210.html#gad5707788b8483b7d434dd860fd516ca4">Dune::XT::Common::Configuration::report()</a>.</p>

</div>
</div>
<a class="anchor" id="a3faf3f0cc31d96e6a8b07672e2bff1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::operator== </td>
          <td>(</td>
          <td class="paramtype">const Configuration &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Configuration &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="a00016.html#a35ed2c3cfa99937991a0ee95496730d1">Dune::XT::Common::Configuration::flatten()</a>.</p>

</div>
</div>
<a class="anchor" id="a7837cf7354d87702504be884e91c76fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00065.html">is_vector</a>&lt;V&gt;::value, void&gt;::type Dune::XT::Common::print </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2dfd39ad309acb7c70f69280155cfac2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00060.html">is_matrix</a>&lt;M&gt;::value, void&gt;::type Dune::XT::Common::print </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66b36372dfa9b56f663819e48960ff0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::real_type_id </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlevel</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create output for demangled typeid </p>

<p>References <a class="el" href="a00201.html#a996fa6182228426117cc70262dfed72b">demangled_type_id()</a>, and <a class="el" href="a00201.html#a73ecf3b38b7bddcb3725d7a83b9cda90">highlight_template()</a>.</p>

</div>
</div>
<a class="anchor" id="a0184fc9212146d42c91446567d99d4d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::reset_signal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset given signal to default handler </p>
<p>POSIX signal management utils.</p>
<p>reset given signal to default handler </p>

<p>Referenced by <a class="el" href="a00201.html#aa20855700748560f9698f4f5a0dee310">handle_interrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="a4622c6f243cfb492ad9e8419bcdb56be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Dune::XT::Common::signum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: -1 iff val &lt; 0 0 iff val == 0 1 iff val &gt; 0 </dd></dl>

<p>Referenced by <a class="el" href="a00207.html#aeeafe5d3bb074328c1217599ab4e4506">Dune::XT::Common::internal::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a8caf0837c4f7fedc89feadaeaf4cb2ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::stringFromTime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>cur_time</em> = <code>time(NULL)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns string with local time in current locale's format </p>

<p>Referenced by <a class="el" href="a00201.html#aa20855700748560f9698f4f5a0dee310">handle_interrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="adf76cf96f4447ff965affc9354cb48c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Dune::XT::Common::template_color_chooser </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00201.html#a73ecf3b38b7bddcb3725d7a83b9cda90">highlight_template()</a>.</p>

</div>
</div>
<a class="anchor" id="ab74fd1ccc1f6dcc37670869d5189e7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::terminal_supports_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is taken from gtest-all.cc! </p>

<p>Referenced by <a class="el" href="a00201.html#ab45942581127492f7595007847b1a26f">color_string()</a>, and <a class="el" href="a00109.html#abd7338917173a31fa62a071b0e852a88">Dune::XT::Common::TimedLogging::create()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b2322cfc02a54be4f99292967f42493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::XT::Common::test_create_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>may include filename, will be stripped </p>

<p>References <a class="el" href="a00201.html#a2986af33e211b303cfab272834afd1b0">directory_only()</a>.</p>

<p>Referenced by <a class="el" href="a00070.html#abdd3668ace17b4ee6ba32483705bdd38">Dune::XT::Common::Logging::create()</a>, <a class="el" href="a00201.html#ac3b8fcbc22dbd95c4787df77e2cb1dab">make_ifstream()</a>, <a class="el" href="a00201.html#a8b53ffdec58036948334e93554725377">make_ofstream()</a>, <a class="el" href="a00016.html#a70c1a32c61a6601a09ee267e63833e14">Dune::XT::Common::Configuration::set_log_on_exit()</a>, <a class="el" href="a00016.html#a344eb054010b511b60eb9fda8724b8e5">Dune::XT::Common::Configuration::set_logfile()</a>, <a class="el" href="a00114.html#acd085cbdd722e9641e91c4c4d03e0662">Dune::XT::Common::Timings::set_outputdir()</a>, and <a class="el" href="a00016.html#a440a109eff1d08ca77f83c806ba44a71">Dune::XT::Common::Configuration::~Configuration()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b628b382f714139846b5f85419b6834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">ThreadManager</a> &amp; Dune::XT::Common::threadManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>global singleton <a class="el" href="a00108.html">ThreadManager</a> </p>

<p>Referenced by <a class="el" href="a00043.html#af16feaaac6b26bc989f6a07b7081d453">Dune::XT::Common::FallbackPerThreadValue&lt; ValueImp &gt;::operator*()</a>, <a class="el" href="a00043.html#aa08c95504efdeb50fb97d8fc0596e58a">Dune::XT::Common::FallbackPerThreadValue&lt; ValueImp &gt;::operator-&gt;()</a>, and <a class="el" href="a00114.html#aa3e7720f14c6eb9b461f21feb3ef9e1b">Dune::XT::Common::Timings::output_all_measures()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a23faeaa700b32a44d1f81a91ba1de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">TimedLogging</a> &amp; Dune::XT::Common::TimedLogger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global instance of the timed logger. </p>
<p>This global logger instance is intended to be used in two ways:</p>
<ul>
<li>Many classes or functions use this instance to log info, debug or warning messages. You can do so in your code by calling the <a class="el" href="a00109.html#a094a038193edf0dd3d3783f384897824">TimedLogging::get()</a> method, providing an identifier that should resemble the current scope: <div class="fragment"><div class="line"><span class="keywordtype">void</span> user_function()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#a094a038193edf0dd3d3783f384897824">get</a>(<span class="stringliteral">&quot;user_function&quot;</span>).<a class="code" href="a00110.html#a47a6fd80b273d38b1d62a60f55489dbe">info</a>() &lt;&lt; <span class="stringliteral">&quot;some information&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ii = 0; ii &lt; 100; ++ii)</div>
<div class="line">    <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#a094a038193edf0dd3d3783f384897824">get</a>(<span class="stringliteral">&quot;user_function&quot;</span>).<a class="code" href="a00110.html#ac318c4ebe5dd057660c9dcb301d368ca">debug</a>() &lt;&lt; <span class="stringliteral">&quot;debug output number &quot;</span> &lt;&lt; ii &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> You can also hold a <a class="el" href="a00110.html" title="A logging manager that provides info, debug and warning streams. ">TimedLogManager</a> object within the current scope or class, if wished: <div class="fragment"><div class="line"><span class="keyword">class </span>UserClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  UserClass()</div>
<div class="line">    : logger_(<a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().get(<span class="stringliteral">&quot;UserClass&quot;</span>))</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> some_method()</div>
<div class="line">  {</div>
<div class="line">    logger_.warn() &lt;&lt; <span class="stringliteral">&quot;something is severly wrong!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  TimedLogManager logger_;</div>
<div class="line">}</div>
</div><!-- fragment --> Each time a new <a class="el" href="a00110.html" title="A logging manager that provides info, debug and warning streams. ">TimedLogManager</a> is created using <a class="el" href="a00109.html#a094a038193edf0dd3d3783f384897824">TimedLogging::get()</a> the loglevel is increased, each time such a logger goes out of scope the loglevel is decreased.</li>
<li>You can use this instance to control the level (and style) of logging you want to have enabled in your application. You should call <a class="el" href="a00109.html#abd7338917173a31fa62a071b0e852a88" title="sets the state ">TimedLogging::create()</a> as soon as possible (and only once!), until then all logging (execpt warnings) is disabled: <div class="fragment"><div class="line"><span class="keywordtype">void</span> silent_function()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> logger = <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#a094a038193edf0dd3d3783f384897824">get</a>(<span class="stringliteral">&quot;silent_function&quot;</span>);</div>
<div class="line">  logger.<a class="code" href="a00110.html#a47a6fd80b273d38b1d62a60f55489dbe">info</a>() &lt;&lt; <span class="stringliteral">&quot;This will never show!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> all_is_well = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (!all_is_well)</div>
<div class="line">    logger.warn() &lt;&lt; <span class="stringliteral">&quot;But this warning will!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#abd7338917173a31fa62a071b0e852a88">create</a>(0,   <span class="comment">// max info level (only the first)</span></div>
<div class="line">                       -1,  <span class="comment">// max debug level (disabled)</span></div>
<div class="line">                       <span class="keyword">true</span> <span class="comment">// warnings are enabled</span></div>
<div class="line">                       );</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> logger = <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#a094a038193edf0dd3d3783f384897824">get</a>(<span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line">  logger.<a class="code" href="a00110.html#a47a6fd80b273d38b1d62a60f55489dbe">info</a>()  &lt;&lt; <span class="stringliteral">&quot;Welcome to my application!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  logger.debug() &lt;&lt; <span class="stringliteral">&quot;This will never show!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  silent_function();</div>
<div class="line">}</div>
</div><!-- fragment --> In addition you can enable coloring of the streams (see <a class="el" href="a00111.html" title="A std::ostream compatible stream that begins every line by printing elapsed time and prefix...">TimedPrefixedLogStream</a>) and give their respective colors, if wished (see the implementation of <a class="el" href="a00201.html#a1e6bc6aa4fa5f4422bf8165e50a66ce3">color_map()</a> or the foreground colors of <a class="el" href="a00014.html" title="namespace to define color constants that can be used to print colored text in an output stream...">Colors</a> for available colors): <div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#abd7338917173a31fa62a071b0e852a88">create</a>(10,          <span class="comment">// max info level</span></div>
<div class="line">                       2,           <span class="comment">// max debug level</span></div>
<div class="line">                       <span class="keyword">true</span>,        <span class="comment">// warnings are enabled (the default)</span></div>
<div class="line">                       <span class="keyword">true</span>,        <span class="comment">// colors are enabled (the default)</span></div>
<div class="line">                       <span class="stringliteral">&quot;white&quot;</span>,     <span class="comment">// info color (the default)</span></div>
<div class="line">                       <span class="stringliteral">&quot;lightgrey&quot;</span>, <span class="comment">// debug color (the default)</span></div>
<div class="line">                       <span class="stringliteral">&quot;red&quot;</span>        <span class="comment">// warning color (the default)</span></div>
<div class="line">                      );</div>
<div class="line"></div>
<div class="line">  <span class="keyword">auto</span> logger = <a class="code" href="a00201.html#a6a23faeaa700b32a44d1f81a91ba1de6">TimedLogger</a>().<a class="code" href="a00109.html#a094a038193edf0dd3d3783f384897824">get</a>(<span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line">  logger.<a class="code" href="a00110.html#a47a6fd80b273d38b1d62a60f55489dbe">info</a>() &lt;&lt; <span class="stringliteral">&quot;&lt;- The &#39;main&#39; prefix left of this should be white!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  logger.warn() &lt;&lt; <span class="stringliteral">&quot;&lt;- The &#39;warn&#39; prefix left of this should be red!&quot;</span>   &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Debug logging is only enabled if NDEBUG is not defined but you might still want to guard calls to logger.debug() for performance reasons. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a9ff4de6a6658c7f9938e6cd88ecd0792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00114.html">Timings</a> &amp; Dune::XT::Common::timings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>XT::Profiler global instance. </p>
<p>global profiler object </p>

<p>Referenced by <a class="el" href="a00102.html#ad80d01e65eaefa90ae205328771cd54c">Dune::XT::Common::ScopedTiming::ScopedTiming()</a>, <a class="el" href="a00081.html#ab9d406a15373676ef4df48fde77b7e31">Dune::XT::Common::OutputScopedTiming::~OutputScopedTiming()</a>, and <a class="el" href="a00102.html#acd934d6f57b95dbc8f47a44be8577da0">Dune::XT::Common::ScopedTiming::~ScopedTiming()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ead21a43b9ca17c453748f5a6aa82b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Dune::XT::Common::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>precision</em> = <code>default_to_string_precision</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an object to string. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00207.html#a223887caa2dc418dfe200377f057fa62">internal::to_string</a> for implementations </dd></dl>

<p>References <a class="el" href="a00207.html#a223887caa2dc418dfe200377f057fa62">Dune::XT::Common::internal::to_string()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#a8e57402eb1a45afba1bebcf6559beb80">backcolor()</a>, <a class="el" href="a00201.html#aae410fa0bf53a8ad1599adca98dfd78a">color()</a>, <a class="el" href="a00016.html#adb212aeda66feacd60b26722eaede793">Dune::XT::Common::Configuration::get_list()</a>, <a class="el" href="a00201.html#a054723b7440cdd5a5174fde345fabef0">highlight_search_string()</a>, <a class="el" href="a00201.html#aa28deec858d5896bacdc9278583a1c38">highlight_string()</a>, <a class="el" href="a00201.html#a73ecf3b38b7bddcb3725d7a83b9cda90">highlight_template()</a>, <a class="el" href="a00201.html#a8018fbe2978d997591faf71ad0f4925b">make_string_sequence()</a>, <a class="el" href="a00129.html#abb9a350ebc83f511e818fbf882197695">Dune::XT::Common::ValidateLess&lt; T &gt;::msg()</a>, <a class="el" href="a00125.html#ae4b4408fc450d82c1f6801db754fdf33">Dune::XT::Common::ValidateGreater&lt; T &gt;::msg()</a>, <a class="el" href="a00211.html#gae9ad462cf09e2d4b49d0d40bb9b67bce">Dune::XT::Common::Configuration::set()</a>, and <a class="el" href="a00201.html#a7583afa226b29992e5c333ade96456ab">whitespaceify()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c12845cd6b781efc6d622bbab090164"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; Dune::XT::Common::tokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::algorithm::token_compress_mode_type&#160;</td>
          <td class="paramname"><em>mode</em> = <code>boost::algorithm::token_compress_off</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper around boost::algorithm::split to split one string into a vector of strings </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the spring to be split </td></tr>
    <tr><td class="paramname">separators</td><td>a list of separators, duh </td></tr>
    <tr><td class="paramname">mode</td><td>token_compress_off &ndash;&gt; potentially empty strings in return, token_compress_on &ndash;&gt; empty tokens are discarded </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all tokens in a vector, if msg contains no separators, this'll contain msg as its only element </dd></dl>

<p>Referenced by <a class="el" href="a00201.html#aa7c008a3400d51bf0f0de9b51f7debd0">dump_environment()</a>, and <a class="el" href="a00112.html#ae05aee0ebf4081a67756bd9b1824dcb2">Dune::XT::Common::TimedPrefixedStreamBuffer::sync()</a>.</p>

</div>
</div>
<a class="anchor" id="ad98cafbf2fb3cb7229138f88c121f366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Dune::XT::Common::tokenize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>separators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::algorithm::token_compress_mode_type&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adae8cb511ffb51c3382ca4618ca3aa94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::XT::Common::touch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pure c++ emulation of system's touch binary </p>

</div>
</div>
<a class="anchor" id="a4e9f619a2046fc67c6a9dba74c7ce858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class sequence  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_enum&lt;T&gt;::value, sequence&gt;::type Dune::XT::Common::value_range </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>increment</em> = <code>Epsilon&lt;T&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector with values in [start : increment : end) </p>

<p>References <a class="el" href="a00201.html#a0362e75a8cb2bfcbff9f03189ae96db7">abs()</a>.</p>

<p>Referenced by <a class="el" href="a00201.html#ae7261086efd006a0964e1d222412dda9">matrix_to_gnuplot_stream()</a>, <a class="el" href="a00114.html#a4694e5825279120910cbc14fdf14560d">Dune::XT::Common::Timings::stop()</a>, <a class="el" href="a00207.html#ab1c0a9524af64859078d226ea564f949">Dune::XT::Common::internal::to_string()</a>, <a class="el" href="a00201.html#a523668e8a8d31bc2583ea3a4f34f9369">value_range()</a>, <a class="el" href="a00201.html#a9dc7158ab050a018724ea5291b21fe78">vector_to_main_args()</a>, and <a class="el" href="a00201.html#a7583afa226b29992e5c333ade96456ab">whitespaceify()</a>.</p>

</div>
</div>
<a class="anchor" id="a523668e8a8d31bc2583ea3a4f34f9369"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class sequence  = std::vector&lt;typename Absretval&lt;T&gt;::type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_enum&lt;T&gt;::value, sequence&gt;::type Dune::XT::Common::value_range </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Absretval&lt; T &gt;::type&#160;</td>
          <td class="paramname"><em>increment</em> = <code>Epsilon&lt;typename&#160;Absretval&lt;T&gt;::type&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signature for enumeration Types T </p>

<p>References <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a361d6033fb7c152dff9062ee6a67e9e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class sequence  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_enum&lt;T&gt;::value, sequence&gt;::type Dune::XT::Common::value_range </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector with values in [0 : Epsilon&lt;T&gt; : end) </p>

<p>References <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a4608b4bd0f42640c3069f22fffa7696e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class sequence  = std::vector&lt;typename Absretval&lt;T&gt;::type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_enum&lt;T&gt;::value, sequence&gt;::type Dune::XT::Common::value_range </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector with values in [0 : Epsilon&lt;T&gt; : end) </p>

<p>References <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc7158ab050a018724ea5291b21fe78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char** Dune::XT::Common::vector_to_main_args </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

</div>
</div>
<a class="anchor" id="a7583afa226b29992e5c333ade96456ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::XT::Common::whitespaceify </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>whitespace</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string of lengths t' whitespace (or whitespace chars). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>defines the length of the return string (after conversion to string) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">whitespace</td><td>char, optional argument, defines entries of return string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string of lengths t' whitespace (or whitespace chars). </dd></dl>

<p>References <a class="el" href="a00195.html#a7d2346fec4c9d4b6a529501c8cd7dad4">DXTC_UNUSED</a>, <a class="el" href="a00201.html#a5ead21a43b9ca17c453748f5a6aa82b1">to_string()</a>, and <a class="el" href="a00201.html#a4e9f619a2046fc67c6a9dba74c7ce858">value_range()</a>.</p>

<p>Referenced by <a class="el" href="a00069.html#a6eab6b9300a2a50666cadc5e406bd8bd">Dune::XT::Common::LocalizationStudy::run()</a>, and <a class="el" href="a00019.html#ac152d2a97d09610f6bf5fbabddaee084">Dune::XT::Common::ConvergenceStudy::run()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="abca605b4ce1c01eaf2b32bd16ffd979f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::size_t Dune::XT::Common::default_to_string_precision = 6u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 13:04:26 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
