<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>dune-gdt: Dune::GDT Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dune-gdt
   &#160;<span id="projectnumber">0.3-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00645.html">Dune</a></li><li class="navelem"><a class="el" href="a00646.html">GDT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dune::GDT Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00647"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00647.html">BaseFunctionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00649"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00649.html">bindings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00650"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00650.html">ESV2007</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00651"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00651.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00652"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00652.html">LocalEllipticIpdgIntegrands</a></td></tr>
<tr class="memdesc:a00652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains local integrands for the family of interior penalty discontinuous Galerkin (IPDG) discretization schemes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00654"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00654.html">LocalSipdgIntegrands</a></td></tr>
<tr class="memdesc:a00654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains local evaluations for the symmetric interior penalty discontinuous Galerkin (SIPDG) discretization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00656"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00656.html">Mapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00657"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00657.html">OS2015</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00658"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00658.html">RS2017</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00660"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00660.html">SpaceTools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">AdaptiveRungeKuttaTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using adaptive Runge Kutta methods.  <a href="a00006.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">AdvectionGodunovOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">AdvectionLaxFriedrichsOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">AdvectionLocalizableDefault</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">AdvectionRHSOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">AnalyticalFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">AnalyticalFluxInterface&lt; E, D, d, R, r, rC, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">AutonomousAnalyticalFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">BaseFunctionSetInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this interface is just to be used for template matching and to allow for access to the backend. All other functionality is enforced by XT::Functions::LocalfunctionSetInterface.  <a href="a00027.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">BlockCgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">BlockDgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">BlockFvSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">BlockMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">BlockRtSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">BlockSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">CgSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">CgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">CheckerboardBasedRhsEvaluationFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">ChooseGridPartView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">CommunicationChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">CommunicationChooser&lt; ViewImp, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">ConstDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">ConstLocalDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">ConstLocalDoFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">ConstraintsInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP interface for all implementations of constraints.  <a href="a00066.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">ContainerBasedStationaryDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">DarcyOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">DefaultProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">DefaultProductMapperFromTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">DefaultProductMapperFromTuple&lt; GridLayerImp, std::tuple&lt; MapperTypes...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">DefaultProductSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">DgSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">DgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">DiffusiveFluxReconstructionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00084.html">DiffusiveFluxReconstructionOperator&lt; GridLayerType, LocalizableFunctionType, void, method &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">DirichletConstraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">DirichletProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">DiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">DuneFemCgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">DuneFemDgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">DuneFemLocalfunctionsCgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">DuneFemLocalfunctionsDgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">DuneFunctionsBaseFunctionSetWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">DuneFunctionsDgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">DuneFunctionsMapperWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">DunePdelabCgMapperWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">DunePdelabCgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">DunePdelabDgMapperWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">DunePdelabDgSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">DunePdelabRtSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">DunePdelabTaylorHoodSpaceWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">EllipticLocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">EllipticMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">EllipticOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">ExplicitRungeKuttaTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using Runge Kutta methods.  <a href="a00115.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">FractionalTimeStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">FunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">FVDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">FvMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">FvMapper&lt; GridLayerImp, 1, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">FvMapper&lt; GridLayerImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">FvProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">FvProductMapper&lt; GridLayerImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">FvProductSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">FvProductSpace&lt; GridLayerImp, RangeFieldImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">FvSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">FvSpace&lt; GridLayerImp, RangeFieldImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">FvSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">FvSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">GlobalFunctionBasedAnalyticalFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00145.html">HyperbolicFVDefaultDiscretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">is_analytical_flux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">is_binary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">is_binary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">is_binary_volume_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">is_binary_volume_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">is_cg_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">is_cg_space&lt; S, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">is_cg_space&lt; S, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">is_const_discrete_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">is_const_discrete_function&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">is_dg_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">is_dg_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">is_discrete_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">is_discrete_function&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">is_fv_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">is_fv_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">is_local_boundary_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html">is_local_coupling_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">is_local_numerical_boundary_flux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">is_local_numerical_coupling_flux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">is_local_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">is_localizable_product</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">is_localizable_product&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">is_matrix_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">is_matrix_operator&lt;T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">is_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">is_operator&lt;T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">is_product_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">is_product_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">is_quaternary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">is_quaternary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">is_restricted_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">is_restricted_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">is_rhs_evaluation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">is_rt_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">is_rt_space&lt; S, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">is_rt_space&lt; S, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">is_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">is_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">is_stationary_discretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">is_stationary_discretization&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">is_unary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">is_unary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">is_unary_volume_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">is_unary_volume_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">IsProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">L2FaceVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">L2GlobalProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">L2GlobalProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">L2GlobalProlongationLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">L2GlobalProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">L2LocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">L2LocalProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">L2LocalProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">L2LocalProlongationLocalizableOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out a prolongation (in a localized manner) using a local L2 projection.  <a href="a00229.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">L2LocalProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">L2MatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">L2Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">L2ProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">L2ProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">L2ProlongationLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">L2ProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">L2VolumeVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">LagrangeProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">LagrangeProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">LagrangeProlongationLocalizableOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out a prolongation (in a localized manner) using a lagrange projection.  <a href="a00247.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html">LagrangeProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">LaplaceLocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00251.html">LaplaceMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html">LaplaceOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00254.html">layer_from_backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">layer_from_backend&lt; Backends::fem &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">layer_from_backend&lt; Backends::functions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00257.html">layer_from_backend&lt; Backends::gdt &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">layer_from_backend&lt; Backends::pdelab &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">LinearReconstructionLocalizable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">LocalBoundaryFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">LocalBoundaryIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">LocalBoundaryOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">LocalBoundaryOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">LocalBoundaryTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">LocalBoundaryTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00269.html">LocalBoundaryTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">LocalCouplingFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">LocalCouplingIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">LocalCouplingOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">LocalCouplingOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html">LocalCouplingTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html">LocalCouplingTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html">LocalCouplingTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">LocalDiffusiveFluxEstimateESV2007Integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">LocalDiffusiveFluxEstimateESV2007Integrand&lt; DiffusionType, DiffusiveFluxType, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00286.html">LocalDiffusiveFluxEstimateStarOS2014Integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">LocalDirichletProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html">LocalDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00291.html">LocalDoFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00292.html">LocalEllipticIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an elliptic evaluation.  <a href="a00292.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00294.html">LocalFaceFunctionalAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00295.html">LocalFaceFunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html">LocalFaceIntegralFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00299.html">LocalFaceIntegrandInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for local evaluations that depend on an intersection.  <a href="a00299.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00300.html">LocalFaceIntegrandInterface&lt; Traits, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for unary codim 1 evaluations.  <a href="a00300.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00301.html">LocalFaceIntegrandInterface&lt; Traits, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for binary codim 1 evaluations.  <a href="a00301.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00302.html">LocalFaceIntegrandInterface&lt; Traits, 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for quaternary codim 1 evaluations.  <a href="a00302.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html">LocalGodunovNumericalBoundaryFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00304.html">LocalGodunovNumericalCouplingFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00305.html">LocalizableDiffusiveFluxReconstructionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00306.html">LocalizableOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00307.html">LocalizableProductBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00308.html">LocalL2ProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html">LocalLagrangeProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.html">LocalLambdaBinaryFaceIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html">LocalLambdaBinaryVolumeIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.html">LocalLambdaOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00318.html">LocalLambdaQuaternaryFaceIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00320.html">LocalLambdaUnaryVolumeIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00322.html">LocalLaxFriedrichsAbsorbingNumericalBoundaryFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00323.html">LocalLaxFriedrichsDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00324.html">LocalLaxFriedrichsNumericalCouplingFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00325.html">LocalNumericalBoundaryFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00326.html">LocalNumericalCouplingFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00327.html">LocalOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html">LocalOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00329.html">LocalProductIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a product evaluation.  <a href="a00329.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00331.html">LocalReconstructionFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00333.html">LocalRhsFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00335.html">LocalVolumeFunctionalAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00336.html">LocalVolumeFunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00339.html">LocalVolumeIntegralFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00340.html">LocalVolumeIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00341.html">LocalVolumeIntegrandInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for local evaluations that depend on a codim 0 entity.  <a href="a00341.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00342.html">LocalVolumeIntegrandInterface&lt; Traits, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for unary codim 0 evaluations.  <a href="a00342.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00343.html">LocalVolumeIntegrandInterface&lt; Traits, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for binary codim 0 evaluations.  <a href="a00343.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00344.html">LocalVolumeTwoFormAccumulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00345.html">LocalVolumeTwoFormAccumulatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00346.html">LocalVolumeTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00347.html">LocalVolumeTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00348.html">LocalVolumeTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00351.html">MapperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00353.html">MatrixOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00366.html">operator_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00367.html">OperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00368.html">OswaldInterpolationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00373.html">ProductDgMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00374.html">ProductDgMapper&lt; PdelabSpaceImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00376.html">ProductMapperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00377.html">ProductSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00379.html">projection_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00380.html">prolongation_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00381.html">ReinterpretDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00384.html">restricted_space_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00385.html">RestrictedMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00387.html">RestrictedSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00389.html">RhsEvaluationFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00393.html">RosenbrockTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using Rosenbrock-type methods.  <a href="a00393.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00394.html">RtSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00395.html">RtSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00396.html">space_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">singleton &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">SpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html">SpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00399.html">SpaceProvider&lt; G, layer, SpaceType::block_cg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00400.html">SpaceProvider&lt; G, layer, SpaceType::block_dg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00401.html">SpaceProvider&lt; G, layer, SpaceType::block_fv, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00402.html">SpaceProvider&lt; G, layer, SpaceType::block_rt, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html">SpaceProvider&lt; G, layer, SpaceType::cg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00404.html">SpaceProvider&lt; G, layer, SpaceType::dg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00405.html">SpaceProvider&lt; G, layer, SpaceType::fv, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00406.html">SpaceProvider&lt; G, layer, SpaceType::rt, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html">StationaryContainerBasedDefaultDiscretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00411.html">StationaryDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00414.html">SystemAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00415.html">TimeStepperFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00416.html">TimeStepperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00417.html">VectorFunctionalBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00421.html">WeightedL2LocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00422.html">WeightedL2MatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00423.html">WeightedL2Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af68dfb986d335b9416add6ef64dfad58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58">SlopeLimiters</a> { <a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58adbc1048da08be92092fbaf26e4561b4d">SlopeLimiters::minmod</a>, 
<a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58ad6fd0924e324f50669ae0295adf59567">SlopeLimiters::mc</a>, 
<a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58adbd796f5b863bc36af8381e5e641ce0e">SlopeLimiters::superbee</a>, 
<a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58a358f8b55910c75c446a7f3418fa87362">SlopeLimiters::no_slope</a>
 }</td></tr>
<tr class="separator:af68dfb986d335b9416add6ef64dfad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c92722e087cefba1ac46ec1fa76f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0">NumericalFluxes</a> { <br />
&#160;&#160;<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0a9399d693b7ac38875e19f1c38c4e4439">NumericalFluxes::godunov</a>, 
<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0a11abd4bf1bf2ac68ae9c63f0d9c72a5c">NumericalFluxes::godunov_with_reconstruction</a>, 
<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0a088da8a28ff265eb3b7e18ae1fc24274">NumericalFluxes::laxfriedrichs</a>, 
<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0aa97df7b1900b45631de1ed54602a398d">NumericalFluxes::laxfriedrichs_with_reconstruction</a>, 
<br />
&#160;&#160;<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0aa5aea357904deb91ca3777416848e6b0">NumericalFluxes::local_laxfriedrichs</a>, 
<a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0a0fcd1a75f10e9072fc5acce97ac9d3ab">NumericalFluxes::local_laxfriedrichs_with_reconstruction</a>
<br />
 }</td></tr>
<tr class="separator:a7d8c92722e087cefba1ac46ec1fa76f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9b3478d77a16697bf06fa3f949e0fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a5a9b3478d77a16697bf06fa3f949e0fa">RosenbrockTimeStepperMethods</a> { <a class="el" href="a00646.html#a5a9b3478d77a16697bf06fa3f949e0faaefc42475d5c88b4e9d7e08dfeda6ef8b">RosenbrockTimeStepperMethods::GRK4A</a>, 
<a class="el" href="a00646.html#a5a9b3478d77a16697bf06fa3f949e0faa9ed047981c608fb1716e2edee87aa5fc">RosenbrockTimeStepperMethods::GRK4T</a>, 
<a class="el" href="a00646.html#a5a9b3478d77a16697bf06fa3f949e0faa795f3202b17cb6bc3d4b771d8c6c9eaf">RosenbrockTimeStepperMethods::other</a>
 }</td></tr>
<tr class="separator:a5a9b3478d77a16697bf06fa3f949e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e79bf2e05d76e877c835fa352f045"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> { <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045a411f822017e8c2a440ad181acfe50efb">Backends::fem</a>, 
<a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045a0eaa46c12c8190dcb4e4b46838220683">Backends::functions</a>, 
<a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a>, 
<a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045a7b681413230ed55022fb3b2e62a300c4">Backends::pdelab</a>
 }</td></tr>
<tr class="separator:afd9e79bf2e05d76e877c835fa352f045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c443ca2e487b92fa4980cd2730b630a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a3c443ca2e487b92fa4980cd2730b630a">ChooseSpaceBackend</a> { <a class="el" href="a00646.html#a3c443ca2e487b92fa4980cd2730b630aa6adf97f83acf6453d4a6a4b1070f3754">ChooseSpaceBackend::None</a>
 }</td></tr>
<tr class="separator:a3c443ca2e487b92fa4980cd2730b630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc558b2ff4b8e95434d41c4e51f6b92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> { <br />
&#160;&#160;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a6e9cf3eef65da697796cf33f27eb0f57">SpaceType::cg</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92ab671d14735bdfcc6cf3ed3d691f5ebf4">SpaceType::block_cg</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a2f7e54fe9de9db73067f562bc22d6eae">SpaceType::dg</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a84fcd17e01407bf423248970c680b91c">SpaceType::block_dg</a>, 
<br />
&#160;&#160;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a3c77f4029be2e609c22bba665f13b101">SpaceType::fv</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92aad8ab1291b6657e98fc69a27f5504619">SpaceType::block_fv</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a822050d9ae3c47f54bee71b85fce1487">SpaceType::rt</a>, 
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92a4d8e6751d2f29f14859df8194924ef6c">SpaceType::block_rt</a>
<br />
 }</td></tr>
<tr class="separator:a1dc558b2ff4b8e95434d41c4e51f6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f2467105da4217b0ff3bb2e4790c7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a09f2467105da4217b0ff3bb2e4790c7e">ChoosePattern</a> { <a class="el" href="a00646.html#a09f2467105da4217b0ff3bb2e4790c7ea210ab9e731c9c36c2c38db15c28a8d1c">ChoosePattern::volume</a>, 
<a class="el" href="a00646.html#a09f2467105da4217b0ff3bb2e4790c7ead5ca322453f2986b752e58b11af83d96">ChoosePattern::face</a>, 
<a class="el" href="a00646.html#a09f2467105da4217b0ff3bb2e4790c7eab68d75779ad98669ad5d654fe30a5827">ChoosePattern::face_and_volume</a>
 }</td></tr>
<tr class="separator:a09f2467105da4217b0ff3bb2e4790c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7e45c07c804e026c31fb0b86b7eb69"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69">TimeStepperMethods</a> { <br />
&#160;&#160;<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69a6715245f54e8e2e94ddb3a731ccbdf10">TimeStepperMethods::bogacki_shampine</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69a696a706c4054d122f1275e54d1bc69c0">TimeStepperMethods::dormand_prince</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69ac97e4d5c331a2936e04feb034fc4f787">TimeStepperMethods::adaptive_rungekutta_other</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69ad8334dcb1e9c0f73386322960f66ace4">TimeStepperMethods::explicit_euler</a>, 
<br />
&#160;&#160;<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69a4bc67bde753aa72be3f0cab932ff12a8">TimeStepperMethods::explicit_rungekutta_second_order_ssp</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69a0e84aa0f9a2d7d6b364450c7a66cd9a0">TimeStepperMethods::explicit_rungekutta_third_order_ssp</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69ab3986d1a2cb34285ab615a07d9b2e8e1">TimeStepperMethods::explicit_rungekutta_classic_fourth_order</a>, 
<a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69a3c2eeed127c2d2355fef6aaeaeac5012">TimeStepperMethods::explicit_rungekutta_other</a>
<br />
 }</td></tr>
<tr class="separator:a0a7e45c07c804e026c31fb0b86b7eb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6b9c4a6f7b668a0b5d89f4f02d9f2257">make_const_discrete_function</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const VectorType &amp;vector, const std::string nm=&quot;gdt.constdiscretefunction&quot;)</td></tr>
<tr class="separator:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6598655545d02249af38a6508ea0681b"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a6598655545d02249af38a6508ea0681b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6598655545d02249af38a6508ea0681b">make_discrete_function</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, VectorType &amp;vector, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a6598655545d02249af38a6508ea0681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a7d3e19a85ebe5c1fbbc4b77437af843c">make_discrete_function</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, VectorType &amp;&amp;vector, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824112d0ae2d504cb60bf725b0b52811"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a824112d0ae2d504cb60bf725b0b52811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a824112d0ae2d504cb60bf725b0b52811">make_discrete_function</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a824112d0ae2d504cb60bf725b0b52811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd434250d655456533847e0fd24550"><td class="memTemplParams" colspan="2">template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a39dd434250d655456533847e0fd24550"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DirichletType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a><br class="typebreak" />
&lt; DirichletType, <br class="typebreak" />
DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a39dd434250d655456533847e0fd24550">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a39dd434250d655456533847e0fd24550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b60716df2a7ff51cc279cefd611be4"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:ae6b60716df2a7ff51cc279cefd611be4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DirichletType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a><br class="typebreak" />
&lt; DirichletType, <br class="typebreak" />
DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ae6b60716df2a7ff51cc279cefd611be4">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ae6b60716df2a7ff51cc279cefd611be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e7e5137ef012766008a318adffd50"><td class="memTemplParams" colspan="2">template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a6a0e7e5137ef012766008a318adffd50"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DirichletType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a><br class="typebreak" />
&lt; DirichletType, DiffusionType, <br class="typebreak" />
void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6a0e7e5137ef012766008a318adffd50">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a6a0e7e5137ef012766008a318adffd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ac26de7ce19c933a4961092550982"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a1d7ac26de7ce19c933a4961092550982"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DirichletType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a><br class="typebreak" />
&lt; DirichletType, <br class="typebreak" />
DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1d7ac26de7ce19c933a4961092550982">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1d7ac26de7ce19c933a4961092550982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DirichletType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a><br class="typebreak" />
&lt; DirichletType, DiffusionType, <br class="typebreak" />
void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a0abcf8a0c7289b894ad73c92ec1aa235">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8c4f6526fc7650a166503429052bd3"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:abe8c4f6526fc7650a166503429052bd3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00243.html">L2VolumeVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#abe8c4f6526fc7650a166503429052bd3">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:abe8c4f6526fc7650a166503429052bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4789d283e11ff2337c91378c073139d"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:af4789d283e11ff2337c91378c073139d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00243.html">L2VolumeVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#af4789d283e11ff2337c91378c073139d">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:af4789d283e11ff2337c91378c073139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f06438b689a0443f35c3fb314021c"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac41f06438b689a0443f35c3fb314021c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00243.html">L2VolumeVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac41f06438b689a0443f35c3fb314021c">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ac41f06438b689a0443f35c3fb314021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efe5fd8a990d2670302e0454aec822f"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5efe5fd8a990d2670302e0454aec822f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00243.html">L2VolumeVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5efe5fd8a990d2670302e0454aec822f">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a5efe5fd8a990d2670302e0454aec822f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b49c6523f019648edfa58bd969a01"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:ad13b49c6523f019648edfa58bd969a01"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad13b49c6523f019648edfa58bd969a01">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ad13b49c6523f019648edfa58bd969a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ae89d3d1d139a3701a04009dd8f4f1b45">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a3ea2165b905a0ab10151dc18ed738a2d">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1f4d4bd089dc21a0aa4b6c1ca31147cb">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88a95427edfbc6c6b5c870231eaad13"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa88a95427edfbc6c6b5c870231eaad13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa88a95427edfbc6c6b5c870231eaad13">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:aa88a95427edfbc6c6b5c870231eaad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36902d54169c4fe3b79ed285b09bfe02"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a36902d54169c4fe3b79ed285b09bfe02"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a36902d54169c4fe3b79ed285b09bfe02">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a36902d54169c4fe3b79ed285b09bfe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aaeb52cbd5b060759f9de394e39eab0f4">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a27a02f887f4a3f3a70d9345e06985b7a">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641c0872fda34a50acf5d8e239b7255"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3641c0872fda34a50acf5d8e239b7255"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a3641c0872fda34a50acf5d8e239b7255">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a3641c0872fda34a50acf5d8e239b7255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a3a531cfd940b7c4bee0e93c711b84b23">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6d1e7607ac4a7de8b39221a64f6a8911">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74f9b73968b13fde92ca858e2580c8a"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab74f9b73968b13fde92ca858e2580c8a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; FunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00218.html">L2FaceVectorFunctional</a><br class="typebreak" />
&lt; FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab74f9b73968b13fde92ca858e2580c8a">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:ab74f9b73968b13fde92ca858e2580c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4435bc1a91769f295e13244775d9366"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad4435bc1a91769f295e13244775d9366"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad4435bc1a91769f295e13244775d9366">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a00065.html">ConstLocalDoFVector</a>&lt; V &gt; &amp;vector)</td></tr>
<tr class="separator:ad4435bc1a91769f295e13244775d9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebd2ad3553f76c53794b395f15d276e"><td class="memTemplParams" colspan="2">template&lt;class G , class F &gt; </td></tr>
<tr class="memitem:abebd2ad3553f76c53794b395f15d276e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a00070.html">DarcyOperator</a><br class="typebreak" />
&lt; G, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#abebd2ad3553f76c53794b395f15d276e">make_darcy</a> (const G &amp;grid_layer, const F &amp;function)</td></tr>
<tr class="separator:abebd2ad3553f76c53794b395f15d276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe374821da426a5bab4966631dfb33be"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:abe374821da426a5bab4966631dfb33be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#abe374821da426a5bab4966631dfb33be">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:abe374821da426a5bab4966631dfb33be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#abe374821da426a5bab4966631dfb33be">More...</a><br /></td></tr>
<tr class="separator:abe374821da426a5bab4966631dfb33be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ae048998935420493a23ee5ea991e"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a723ae048998935420493a23ee5ea991e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a723ae048998935420493a23ee5ea991e">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a723ae048998935420493a23ee5ea991e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#a723ae048998935420493a23ee5ea991e">More...</a><br /></td></tr>
<tr class="separator:a723ae048998935420493a23ee5ea991e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27716e9a50252e78dfbd00882f043510"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a27716e9a50252e78dfbd00882f043510"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a27716e9a50252e78dfbd00882f043510">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a27716e9a50252e78dfbd00882f043510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space).  <a href="#a27716e9a50252e78dfbd00882f043510">More...</a><br /></td></tr>
<tr class="separator:a27716e9a50252e78dfbd00882f043510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731877def65722027447923a18bfe442"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a731877def65722027447923a18bfe442"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a731877def65722027447923a18bfe442">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a731877def65722027447923a18bfe442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space).  <a href="#a731877def65722027447923a18bfe442">More...</a><br /></td></tr>
<tr class="separator:a731877def65722027447923a18bfe442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0020b01053f44190ce800c02c652c4d"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad0020b01053f44190ce800c02c652c4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad0020b01053f44190ce800c02c652c4d">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad0020b01053f44190ce800c02c652c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used).  <a href="#ad0020b01053f44190ce800c02c652c4d">More...</a><br /></td></tr>
<tr class="separator:ad0020b01053f44190ce800c02c652c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, method, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aaa5d861f8a59da22b6c952478fe8a3ff">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied).  <a href="#aaa5d861f8a59da22b6c952478fe8a3ff">More...</a><br /></td></tr>
<tr class="separator:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a8f11e994cb65b886bfd653202a76"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ae48a8f11e994cb65b886bfd653202a76"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ae48a8f11e994cb65b886bfd653202a76">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ae48a8f11e994cb65b886bfd653202a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#ae48a8f11e994cb65b886bfd653202a76">More...</a><br /></td></tr>
<tr class="separator:ae48a8f11e994cb65b886bfd653202a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa185548adae9af94131880d62bbabc7e"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa185548adae9af94131880d62bbabc7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa185548adae9af94131880d62bbabc7e">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa185548adae9af94131880d62bbabc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#aa185548adae9af94131880d62bbabc7e">More...</a><br /></td></tr>
<tr class="separator:aa185548adae9af94131880d62bbabc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e606467a37be4814415340f0e730c"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad88e606467a37be4814415340f0e730c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad88e606467a37be4814415340f0e730c">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad88e606467a37be4814415340f0e730c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space).  <a href="#ad88e606467a37be4814415340f0e730c">More...</a><br /></td></tr>
<tr class="separator:ad88e606467a37be4814415340f0e730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f1b52002d4f069041329ad968ebc8"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa50f1b52002d4f069041329ad968ebc8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
method, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa50f1b52002d4f069041329ad968ebc8">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa50f1b52002d4f069041329ad968ebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space).  <a href="#aa50f1b52002d4f069041329ad968ebc8">More...</a><br /></td></tr>
<tr class="separator:aa50f1b52002d4f069041329ad968ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11326936be89261963fcc56f41c15462"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a11326936be89261963fcc56f41c15462"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a11326936be89261963fcc56f41c15462">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a11326936be89261963fcc56f41c15462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used).  <a href="#a11326936be89261963fcc56f41c15462">More...</a><br /></td></tr>
<tr class="separator:a11326936be89261963fcc56f41c15462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, method, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a8ef7bbeba344f2badd87c6eb96677e3b">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied).  <a href="#a8ef7bbeba344f2badd87c6eb96677e3b">More...</a><br /></td></tr>
<tr class="separator:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1687b0deb307fedd89aa3ce0420443f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac1687b0deb307fedd89aa3ce0420443f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac1687b0deb307fedd89aa3ce0420443f">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac1687b0deb307fedd89aa3ce0420443f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#ac1687b0deb307fedd89aa3ce0420443f">More...</a><br /></td></tr>
<tr class="separator:ac1687b0deb307fedd89aa3ce0420443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a244d38839d3e1f19883cdd2b1dd07f3c">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#a244d38839d3e1f19883cdd2b1dd07f3c">More...</a><br /></td></tr>
<tr class="separator:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5d7d95d7700b45a8690ba2bc6a8bb020">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space).  <a href="#a5d7d95d7700b45a8690ba2bc6a8bb020">More...</a><br /></td></tr>
<tr class="separator:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1154218ae80f409ab597655b27e3ec"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a0e1154218ae80f409ab597655b27e3ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a0e1154218ae80f409ab597655b27e3ec">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a0e1154218ae80f409ab597655b27e3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space).  <a href="#a0e1154218ae80f409ab597655b27e3ec">More...</a><br /></td></tr>
<tr class="separator:a0e1154218ae80f409ab597655b27e3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe0640b34f33baafaadb61e440d80a2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a2fe0640b34f33baafaadb61e440d80a2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a2fe0640b34f33baafaadb61e440d80a2">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a2fe0640b34f33baafaadb61e440d80a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used).  <a href="#a2fe0640b34f33baafaadb61e440d80a2">More...</a><br /></td></tr>
<tr class="separator:a2fe0640b34f33baafaadb61e440d80a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac305bd91061a17898645ef78e47ad11f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ac305bd91061a17898645ef78e47ad11f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, method, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac305bd91061a17898645ef78e47ad11f">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac305bd91061a17898645ef78e47ad11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied).  <a href="#ac305bd91061a17898645ef78e47ad11f">More...</a><br /></td></tr>
<tr class="separator:ac305bd91061a17898645ef78e47ad11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5a19aae1548e2aaa5c4ad71b6a72466a">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#a5a19aae1548e2aaa5c4ad71b6a72466a">More...</a><br /></td></tr>
<tr class="separator:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819bbf4e4799bf4501031a635645b40"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa819bbf4e4799bf4501031a635645b40"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa819bbf4e4799bf4501031a635645b40">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa819bbf4e4799bf4501031a635645b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#aa819bbf4e4799bf4501031a635645b40">More...</a><br /></td></tr>
<tr class="separator:aa819bbf4e4799bf4501031a635645b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a4ccb6c2d56014a31dfa7f96fc6358919">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space).  <a href="#a4ccb6c2d56014a31dfa7f96fc6358919">More...</a><br /></td></tr>
<tr class="separator:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5008a3fbbd914460f557f656d83328"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f5008a3fbbd914460f557f656d83328"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1f5008a3fbbd914460f557f656d83328">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a1f5008a3fbbd914460f557f656d83328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space).  <a href="#a1f5008a3fbbd914460f557f656d83328">More...</a><br /></td></tr>
<tr class="separator:a1f5008a3fbbd914460f557f656d83328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, <br class="typebreak" />
<a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a26a1a51d0e80b2681d20c0f1b5b8bd94">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used).  <a href="#a26a1a51d0e80b2681d20c0f1b5b8bd94">More...</a><br /></td></tr>
<tr class="separator:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, method, <br class="typebreak" />
MatrixType, GridLayerType, <br class="typebreak" />
SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1f8f8f71e1f1d2e056507159a06a4dad">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied).  <a href="#a1f8f8f71e1f1d2e056507159a06a4dad">More...</a><br /></td></tr>
<tr class="separator:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084a763666c2ec7e18e1d161bf060a63"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a084a763666c2ec7e18e1d161bf060a63"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; RangeType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00111.html">EllipticLocalizableProduct</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
GridLayerType, RangeType, <br class="typebreak" />
SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a084a763666c2ec7e18e1d161bf060a63">make_elliptic_localizable_product</a> (const DiffusionType &amp;diffusion, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0)</td></tr>
<tr class="separator:a084a763666c2ec7e18e1d161bf060a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa3248c4c2349d26b6ebdd92c57599c"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a5fa3248c4c2349d26b6ebdd92c57599c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; RangeType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00111.html">EllipticLocalizableProduct</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
GridLayerType, RangeType, <br class="typebreak" />
SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5fa3248c4c2349d26b6ebdd92c57599c">make_elliptic_localizable_product</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0)</td></tr>
<tr class="separator:a5fa3248c4c2349d26b6ebdd92c57599c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a8e5ac11789f5a6a20eb9c4c591f7590f">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a8e5ac11789f5a6a20eb9c4c591f7590f">More...</a><br /></td></tr>
<tr class="separator:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa2b417cfe37ddd413a1a88f8d4832b7d">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#aa2b417cfe37ddd413a1a88f8d4832b7d">More...</a><br /></td></tr>
<tr class="separator:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e8de41cd99705c54a463ff8979abb4"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad4e8de41cd99705c54a463ff8979abb4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad4e8de41cd99705c54a463ff8979abb4">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad4e8de41cd99705c54a463ff8979abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#ad4e8de41cd99705c54a463ff8979abb4">More...</a><br /></td></tr>
<tr class="separator:ad4e8de41cd99705c54a463ff8979abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac79ebd71eca30efd87b6f57c0f49f600">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac79ebd71eca30efd87b6f57c0f49f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#ac79ebd71eca30efd87b6f57c0f49f600">More...</a><br /></td></tr>
<tr class="separator:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f78e3513c8c8445e9b7065419041030"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a6f78e3513c8c8445e9b7065419041030"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6f78e3513c8c8445e9b7065419041030">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a6f78e3513c8c8445e9b7065419041030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (source and range space are given by space).  <a href="#a6f78e3513c8c8445e9b7065419041030">More...</a><br /></td></tr>
<tr class="separator:a6f78e3513c8c8445e9b7065419041030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad4f6e182a9cecb5d8c8f9bb6da507e36">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator.  <a href="#ad4f6e182a9cecb5d8c8f9bb6da507e36">More...</a><br /></td></tr>
<tr class="separator:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645898ad9e18b9ee082694eb129be6e5"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a645898ad9e18b9ee082694eb129be6e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a645898ad9e18b9ee082694eb129be6e5">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a645898ad9e18b9ee082694eb129be6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a645898ad9e18b9ee082694eb129be6e5">More...</a><br /></td></tr>
<tr class="separator:a645898ad9e18b9ee082694eb129be6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a59f7a9e88dc8fb3ea1bc7b5847d148e2">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a59f7a9e88dc8fb3ea1bc7b5847d148e2">More...</a><br /></td></tr>
<tr class="separator:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b492fe167180d66b57155a9c4efc20"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab1b492fe167180d66b57155a9c4efc20"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab1b492fe167180d66b57155a9c4efc20">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ab1b492fe167180d66b57155a9c4efc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically).  <a href="#ab1b492fe167180d66b57155a9c4efc20">More...</a><br /></td></tr>
<tr class="separator:ab1b492fe167180d66b57155a9c4efc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b224a5d8038ccad232f22cd4f94392c"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a4b224a5d8038ccad232f22cd4f94392c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a4b224a5d8038ccad232f22cd4f94392c">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4b224a5d8038ccad232f22cd4f94392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, source and range space are given by space, grid_layer of the space is used).  <a href="#a4b224a5d8038ccad232f22cd4f94392c">More...</a><br /></td></tr>
<tr class="separator:a4b224a5d8038ccad232f22cd4f94392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad25dd39c95e458ac83ee12b6f50b105d">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad25dd39c95e458ac83ee12b6f50b105d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, source and range space are given by space).  <a href="#ad25dd39c95e458ac83ee12b6f50b105d">More...</a><br /></td></tr>
<tr class="separator:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b601eea0442b605302ad79f18056d87"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4b601eea0442b605302ad79f18056d87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00112.html">EllipticMatrixOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a4b601eea0442b605302ad79f18056d87">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4b601eea0442b605302ad79f18056d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given).  <a href="#a4b601eea0442b605302ad79f18056d87">More...</a><br /></td></tr>
<tr class="separator:a4b601eea0442b605302ad79f18056d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d25b2d08b99737792191ea9dc56b529"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class DiffusionType &gt; </td></tr>
<tr class="memitem:a6d25b2d08b99737792191ea9dc56b529"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00113.html">EllipticOperator</a><br class="typebreak" />
&lt; DiffusionType, void, <br class="typebreak" />
GridLayerType, typename <br class="typebreak" />
DiffusionType::RangeFieldType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6d25b2d08b99737792191ea9dc56b529">make_elliptic_operator</a> (const GridLayerType &amp;grid_layer, const DiffusionType &amp;diffusion, const size_t over_integrate=0)</td></tr>
<tr class="separator:a6d25b2d08b99737792191ea9dc56b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class DiffusionFactorType , class DiffusionTensorType &gt; </td></tr>
<tr class="memitem:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionFactorType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; DiffusionTensorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00113.html">EllipticOperator</a><br class="typebreak" />
&lt; DiffusionFactorType, <br class="typebreak" />
DiffusionTensorType, <br class="typebreak" />
GridLayerType, typename <br class="typebreak" />
DiffusionFactorType::RangeFieldType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1757fab0086f1e2e9767645fc23fd9c5">make_elliptic_operator</a> (const GridLayerType &amp;grid_layer, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method m, class GL , class DF , class DT &gt; </td></tr>
<tr class="memitem:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00083.html">DiffusiveFluxReconstructionOperator</a><br class="typebreak" />
&lt; GL, DF, DT, m &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a0ef1828dbb87ea7925b06e2fb3592981">make_diffusive_flux_reconstruction_operator</a> (const GL &amp;grid_layer, const DF &amp;diffusion_factor, const DT &amp;diffusion_tensor, const size_t over_integrate=0)</td></tr>
<tr class="separator:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24db0c68e2159dc885e41c182ab1ffaf"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a24db0c68e2159dc885e41c182ab1ffaf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; RangeType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00225.html">L2LocalizableProduct</a><br class="typebreak" />
&lt; GridLayerType, RangeType, <br class="typebreak" />
SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a24db0c68e2159dc885e41c182ab1ffaf">make_l2_localizable_product</a> (const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0)</td></tr>
<tr class="separator:a24db0c68e2159dc885e41c182ab1ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa6df3ece6d2703ff6bedf3420c5e3a95">make_l2_matrix_operator</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#aa6df3ece6d2703ff6bedf3420c5e3a95">More...</a><br /></td></tr>
<tr class="separator:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a19320cc6468677248b8ab4eed3b3de"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4a19320cc6468677248b8ab4eed3b3de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a4a19320cc6468677248b8ab4eed3b3de">make_l2_matrix_operator</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4a19320cc6468677248b8ab4eed3b3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a4a19320cc6468677248b8ab4eed3b3de">More...</a><br /></td></tr>
<tr class="separator:a4a19320cc6468677248b8ab4eed3b3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a><br class="typebreak" />
&lt; RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a59bd3e4a730d2e05605abbee7bcd9baf">make_l2_matrix_operator</a> (const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a59bd3e4a730d2e05605abbee7bcd9baf">More...</a><br /></td></tr>
<tr class="separator:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca65e541579ace42958d0248e85dc8e"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aaca65e541579ace42958d0248e85dc8e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aaca65e541579ace42958d0248e85dc8e">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aaca65e541579ace42958d0248e85dc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#aaca65e541579ace42958d0248e85dc8e">More...</a><br /></td></tr>
<tr class="separator:aaca65e541579ace42958d0248e85dc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
MatrixType, GridLayerType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a3aa7d90d3f800e69ceb9956818a7ab29">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (source and range space are given by space).  <a href="#a3aa7d90d3f800e69ceb9956818a7ab29">More...</a><br /></td></tr>
<tr class="separator:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8805736f27ea9f91b346e93251ffcaf"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa8805736f27ea9f91b346e93251ffcaf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00232.html">L2MatrixOperator</a><br class="typebreak" />
&lt; RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa8805736f27ea9f91b346e93251ffcaf">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa8805736f27ea9f91b346e93251ffcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator.  <a href="#aa8805736f27ea9f91b346e93251ffcaf">More...</a><br /></td></tr>
<tr class="separator:aa8805736f27ea9f91b346e93251ffcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr&lt; <a class="el" href="a00233.html">L2Operator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aaa8d9d3c704dad52fe1215c40ce7755e">make_l2_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98af1b0075368ee591155362a770327e"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a98af1b0075368ee591155362a770327e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; RangeType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00250.html">LaplaceLocalizableProduct</a><br class="typebreak" />
&lt; GridLayerType, RangeType, <br class="typebreak" />
SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a98af1b0075368ee591155362a770327e">make_laplace_localizable_product</a> (const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0)</td></tr>
<tr class="separator:a98af1b0075368ee591155362a770327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58267637036be6ee37f0e48d1162ab0"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac58267637036be6ee37f0e48d1162ab0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac58267637036be6ee37f0e48d1162ab0">make_laplace_matrix_operator</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac58267637036be6ee37f0e48d1162ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#ac58267637036be6ee37f0e48d1162ab0">More...</a><br /></td></tr>
<tr class="separator:ac58267637036be6ee37f0e48d1162ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e793f951853fe2462720fbdb0efe2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab45e793f951853fe2462720fbdb0efe2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab45e793f951853fe2462720fbdb0efe2">make_laplace_matrix_operator</a> (const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ab45e793f951853fe2462720fbdb0efe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#ab45e793f951853fe2462720fbdb0efe2">More...</a><br /></td></tr>
<tr class="separator:ab45e793f951853fe2462720fbdb0efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c2435913bbaefd577916a044eeaff"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a187c2435913bbaefd577916a044eeaff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a187c2435913bbaefd577916a044eeaff">make_laplace_matrix_operator</a> (const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a187c2435913bbaefd577916a044eeaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a187c2435913bbaefd577916a044eeaff">More...</a><br /></td></tr>
<tr class="separator:a187c2435913bbaefd577916a044eeaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a73a1412fbe2dd31bb9c7c48f943fecb8">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#a73a1412fbe2dd31bb9c7c48f943fecb8">More...</a><br /></td></tr>
<tr class="separator:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f40f54739e0f5758158c62af274630"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa2f40f54739e0f5758158c62af274630"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa2f40f54739e0f5758158c62af274630">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa2f40f54739e0f5758158c62af274630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (source and range space are given by space).  <a href="#aa2f40f54739e0f5758158c62af274630">More...</a><br /></td></tr>
<tr class="separator:aa2f40f54739e0f5758158c62af274630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfd627da92f1aa70984f784203f0f57"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5bfd627da92f1aa70984f784203f0f57"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00251.html">LaplaceMatrixOperator</a><br class="typebreak" />
&lt; RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5bfd627da92f1aa70984f784203f0f57">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5bfd627da92f1aa70984f784203f0f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator.  <a href="#a5bfd627da92f1aa70984f784203f0f57">More...</a><br /></td></tr>
<tr class="separator:a5bfd627da92f1aa70984f784203f0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c77184eaff56d640da03fc408d27b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a614c77184eaff56d640da03fc408d27b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00252.html">LaplaceOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a614c77184eaff56d640da03fc408d27b">make_laplace_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a614c77184eaff56d640da03fc408d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b041e261527d21bda30b8a0cfd22e66"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a2b041e261527d21bda30b8a0cfd22e66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; RangeType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00421.html">WeightedL2LocalizableProduct</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
GridLayerType, RangeType, <br class="typebreak" />
SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a2b041e261527d21bda30b8a0cfd22e66">make_weighted_l2_localizable_product</a> (const WeightFunctionType &amp;weight, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0)</td></tr>
<tr class="separator:a2b041e261527d21bda30b8a0cfd22e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c370bc5da752091bf363382ccad66f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a94c370bc5da752091bf363382ccad66f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a94c370bc5da752091bf363382ccad66f">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a94c370bc5da752091bf363382ccad66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a94c370bc5da752091bf363382ccad66f">More...</a><br /></td></tr>
<tr class="separator:a94c370bc5da752091bf363382ccad66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d49e35616d30a21a82601a8358d85"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a419d49e35616d30a21a82601a8358d85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a419d49e35616d30a21a82601a8358d85">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a419d49e35616d30a21a82601a8358d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a419d49e35616d30a21a82601a8358d85">More...</a><br /></td></tr>
<tr class="separator:a419d49e35616d30a21a82601a8358d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790f22db7ca14a73ae19e9993742320"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a8790f22db7ca14a73ae19e9993742320"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a8790f22db7ca14a73ae19e9993742320">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8790f22db7ca14a73ae19e9993742320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a8790f22db7ca14a73ae19e9993742320">More...</a><br /></td></tr>
<tr class="separator:a8790f22db7ca14a73ae19e9993742320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c65510f0494c44231137be7b61eb712"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a6c65510f0494c44231137be7b61eb712"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6c65510f0494c44231137be7b61eb712">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a6c65510f0494c44231137be7b61eb712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#a6c65510f0494c44231137be7b61eb712">More...</a><br /></td></tr>
<tr class="separator:a6c65510f0494c44231137be7b61eb712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, <br class="typebreak" />
GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a7fa80f01415bd014fdc5dd79dd286edc">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a7fa80f01415bd014fdc5dd79dd286edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (source and range space are given by space).  <a href="#a7fa80f01415bd014fdc5dd79dd286edc">More...</a><br /></td></tr>
<tr class="separator:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ae6d54b1de546de981980dcc26c961"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:af9ae6d54b1de546de981980dcc26c961"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_matrix<br class="typebreak" />
&lt; MatrixType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;<a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00422.html">WeightedL2MatrixOperator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
RangeSpaceType, MatrixType, <br class="typebreak" />
GridLayerType, SourceSpaceType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#af9ae6d54b1de546de981980dcc26c961">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:af9ae6d54b1de546de981980dcc26c961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator.  <a href="#af9ae6d54b1de546de981980dcc26c961">More...</a><br /></td></tr>
<tr class="separator:af9ae6d54b1de546de981980dcc26c961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f2e7c92b7268e11b82ccea2407271"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class WeightFunctionType &gt; </td></tr>
<tr class="memitem:ac54f2e7c92b7268e11b82ccea2407271"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; WeightFunctionType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00423.html">WeightedL2Operator</a><br class="typebreak" />
&lt; WeightFunctionType, <br class="typebreak" />
GridLayerType, typename <br class="typebreak" />
WeightFunctionType::RangeFieldType &gt;<br class="typebreak" />
 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac54f2e7c92b7268e11b82ccea2407271">make_weighted_l2_operator</a> (const GridLayerType &amp;grid_layer, const WeightFunctionType &amp;weight, const size_t over_integrate=0)</td></tr>
<tr class="separator:ac54f2e7c92b7268e11b82ccea2407271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class RangeType &gt; </td></tr>
<tr class="memitem:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00087.html">DirichletProjectionLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, SourceType, <br class="typebreak" />
RangeType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a8f639f3b2734291a3ab3c17c8894fdcb">make_localizable_dirichlet_projection_operator</a> (const GridLayerType &amp;grid_layer, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const SourceType &amp;source, RangeType &amp;range)</td></tr>
<tr class="separator:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00219.html">L2GlobalProjectionLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, SourceType, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab6adbf86b5d86a023e2e8e93cbcbc6d5">make_global_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5f8915864e0699caf07017b3f0bbd9"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ada5f8915864e0699caf07017b3f0bbd9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00219.html">L2GlobalProjectionLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
SpaceType::GridLayerType, <br class="typebreak" />
SourceType, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;<br class="typebreak" />
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ada5f8915864e0699caf07017b3f0bbd9">make_global_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ada5f8915864e0699caf07017b3f0bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00220.html">L2GlobalProjectionOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1dc211dfec7d3c46b5d59c7b1403bdf5">make_global_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc202d2e4d8bf8790417229f396a5c"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:af7bc202d2e4d8bf8790417229f396a5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00226.html">L2LocalProjectionLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, SourceType, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#af7bc202d2e4d8bf8790417229f396a5c">make_local_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:af7bc202d2e4d8bf8790417229f396a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9a11474b9b3aba686860d733a88d1a"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:aff9a11474b9b3aba686860d733a88d1a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00226.html">L2LocalProjectionLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
SpaceType::GridLayerType, <br class="typebreak" />
SourceType, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;<br class="typebreak" />
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aff9a11474b9b3aba686860d733a88d1a">make_local_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:aff9a11474b9b3aba686860d733a88d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72af8b84996d16c4b31bbceaceefca6f"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a72af8b84996d16c4b31bbceaceefca6f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00227.html">L2LocalProjectionOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a72af8b84996d16c4b31bbceaceefca6f">make_local_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a72af8b84996d16c4b31bbceaceefca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb37c26aebc4f0de53587319f55a017b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:abb37c26aebc4f0de53587319f55a017b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00235.html">L2ProjectionLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, SourceType, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#abb37c26aebc4f0de53587319f55a017b">make_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:abb37c26aebc4f0de53587319f55a017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fda08c8477972bb5135da2513518dc"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:aa1fda08c8477972bb5135da2513518dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00235.html">L2ProjectionLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
SpaceType::GridLayerType, <br class="typebreak" />
SourceType, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;<br class="typebreak" />
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa1fda08c8477972bb5135da2513518dc">make_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:aa1fda08c8477972bb5135da2513518dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00237.html">L2ProjectionOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a53207d499f1a26958db4d5efb6ba6bdb">make_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1a4243d386c3a6575feb6fe3fb2109"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a4c1a4243d386c3a6575feb6fe3fb2109"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a4c1a4243d386c3a6575feb6fe3fb2109">project_l2</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a4c1a4243d386c3a6575feb6fe3fb2109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86840014ba403445a5c8d9411621faf9"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a86840014ba403445a5c8d9411621faf9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a86840014ba403445a5c8d9411621faf9">project_l2</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a86840014ba403445a5c8d9411621faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac883c6de02a9d52128dd3b2003883c25"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ac883c6de02a9d52128dd3b2003883c25"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00244.html">LagrangeProjectionLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, SourceType, <br class="typebreak" />
<a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <br class="typebreak" />
VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ac883c6de02a9d52128dd3b2003883c25">make_lagrange_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range)</td></tr>
<tr class="separator:ac883c6de02a9d52128dd3b2003883c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6917e0c8e9271cd8993ecb18b551ae"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:aef6917e0c8e9271cd8993ecb18b551ae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00244.html">LagrangeProjectionLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
SpaceType::GridLayerType, <br class="typebreak" />
SourceType, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;<br class="typebreak" />
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aef6917e0c8e9271cd8993ecb18b551ae">make_lagrange_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range)</td></tr>
<tr class="separator:aef6917e0c8e9271cd8993ecb18b551ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd9942fa032bb572db38180e9602c4e"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a6bd9942fa032bb572db38180e9602c4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00245.html">LagrangeProjectionOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a6bd9942fa032bb572db38180e9602c4e">make_lagrange_projection_operator</a> (const GridLayerType &amp;grid_layer)</td></tr>
<tr class="separator:a6bd9942fa032bb572db38180e9602c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c75b8be21f9395bd635da5aa2ae169"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a41c75b8be21f9395bd635da5aa2ae169"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a41c75b8be21f9395bd635da5aa2ae169">project_lagrange</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range)</td></tr>
<tr class="separator:a41c75b8be21f9395bd635da5aa2ae169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13df6c545215f77354ce5e7195100ee"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab13df6c545215f77354ce5e7195100ee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab13df6c545215f77354ce5e7195100ee">project_lagrange</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range)</td></tr>
<tr class="separator:ab13df6c545215f77354ce5e7195100ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00158.html">is_cg_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab28f3c4b54b4fb8206d8b24f2f2c1e32">project</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;!<a class="el" href="a00158.html">is_cg_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab6930f61566d99bf1e2ad1a1ea8ebdda">project</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2246f50ebf840a99127b39c957faadf"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab2246f50ebf840a99127b39c957faadf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00158.html">is_cg_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab2246f50ebf840a99127b39c957faadf">project</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:ab2246f50ebf840a99127b39c957faadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Functions::is_localizable_function<br class="typebreak" />
&lt; SourceType &gt;::value <br class="typebreak" />
&amp;&amp;!<a class="el" href="a00158.html">is_cg_space</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; VectorType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#add15cc27cd3d12bd7a1e30e5bf37224f">project</a> (const SourceType &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639a3d279612f1a236d81216fb81a7b8"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a639a3d279612f1a236d81216fb81a7b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; SourceSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; SourceVectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; RangeVectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00222.html">L2GlobalProlongationLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a639a3d279612f1a236d81216fb81a7b8">make_global_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a639a3d279612f1a236d81216fb81a7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18eac69cefdad4ac3eb8063a23a2b41"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aa18eac69cefdad4ac3eb8063a23a2b41"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; SourceVectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; RangeVectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00222.html">L2GlobalProlongationLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
RangeSpaceType::GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa18eac69cefdad4ac3eb8063a23a2b41">make_global_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:aa18eac69cefdad4ac3eb8063a23a2b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a3610e71d59f474af2dfd988fc868"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a564a3610e71d59f474af2dfd988fc868"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00223.html">L2GlobalProlongationOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a564a3610e71d59f474af2dfd988fc868">make_global_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a564a3610e71d59f474af2dfd988fc868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5266097dd59841669c823330c03b5771"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a5266097dd59841669c823330c03b5771"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; SourceSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; SourceVectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; RangeVectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00229.html">L2LocalProlongationLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5266097dd59841669c823330c03b5771">make_local_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a5266097dd59841669c823330c03b5771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d51db21eef9fa649d8e6208639a77"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a610d51db21eef9fa649d8e6208639a77"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00198.html">is_space</a><br class="typebreak" />
&lt; SourceSpaceType &gt;::value <br class="typebreak" />
&amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; SourceVectorType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00198.html">is_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value &amp;&amp;XT::LA::is_vector<br class="typebreak" />
&lt; RangeVectorType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00229.html">L2LocalProlongationLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
RangeSpaceType::GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a610d51db21eef9fa649d8e6208639a77">make_local_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a610d51db21eef9fa649d8e6208639a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00230.html">L2LocalProlongationOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ae259c74e23bd82ed2bdb7bc190df8093">make_local_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a059579e9a8e50834a6763bdc62ab4"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:ad7a059579e9a8e50834a6763bdc62ab4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00239.html">L2ProlongationLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt;<br class="typebreak" />
 &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ad7a059579e9a8e50834a6763bdc62ab4">make_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ad7a059579e9a8e50834a6763bdc62ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3431709faed7b4fc53cc909140f9a96b"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a3431709faed7b4fc53cc909140f9a96b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00239.html">L2ProlongationLocalizableOperator</a><br class="typebreak" />
&lt; typename RS::GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a3431709faed7b4fc53cc909140f9a96b">make_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a3431709faed7b4fc53cc909140f9a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f74bd1b2248a25d0c380d3464f4724"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a66f74bd1b2248a25d0c380d3464f4724"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00241.html">L2ProlongationOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a66f74bd1b2248a25d0c380d3464f4724">make_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a66f74bd1b2248a25d0c380d3464f4724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fab99cb387849e714c05a0d2b27c197"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a8fab99cb387849e714c05a0d2b27c197"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a8fab99cb387849e714c05a0d2b27c197">prolong_l2</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a8fab99cb387849e714c05a0d2b27c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a961b32a7982c5bf781045fbfa0eb9aab">prolong_l2</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76ee38cc1a53992ee3902192ed7748b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:ae76ee38cc1a53992ee3902192ed7748b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00247.html">LagrangeProlongationLocalizableOperator</a><br class="typebreak" />
&lt; GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ae76ee38cc1a53992ee3902192ed7748b">make_lagrange_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range)</td></tr>
<tr class="separator:ae76ee38cc1a53992ee3902192ed7748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17ad63fd7b207e96711ddf24b5a3b49"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:ab17ad63fd7b207e96711ddf24b5a3b49"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00247.html">LagrangeProlongationLocalizableOperator</a><br class="typebreak" />
&lt; typename <br class="typebreak" />
RangeSpaceType::GridLayerType, <br class="typebreak" />
<a class="el" href="a00063.html">ConstDiscreteFunction</a><br class="typebreak" />
&lt; SourceSpaceType, <br class="typebreak" />
SourceVectorType &gt;<br class="typebreak" />
, <a class="el" href="a00088.html">DiscreteFunction</a><br class="typebreak" />
&lt; RangeSpaceType, <br class="typebreak" />
RangeVectorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab17ad63fd7b207e96711ddf24b5a3b49">make_lagrange_prolongation_localizable_operator</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range)</td></tr>
<tr class="separator:ab17ad63fd7b207e96711ddf24b5a3b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a31d2d051596296e00ceea186232b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:ab39a31d2d051596296e00ceea186232b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, <br class="typebreak" />
std::unique_ptr<br class="typebreak" />
&lt; <a class="el" href="a00248.html">LagrangeProlongationOperator</a><br class="typebreak" />
&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#ab39a31d2d051596296e00ceea186232b">make_lagrange_prolongation_operator</a> (const GridLayerType &amp;grid_layer)</td></tr>
<tr class="separator:ab39a31d2d051596296e00ceea186232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d568aa7a7ad273010bb8431fe418d8b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a1d568aa7a7ad273010bb8431fe418d8b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value, void &gt;<br class="typebreak" />
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a1d568aa7a7ad273010bb8431fe418d8b">prolong_lagrange</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range)</td></tr>
<tr class="separator:a1d568aa7a7ad273010bb8431fe418d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ef049aab400d95175eec9fa916dc15"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a41ef049aab400d95175eec9fa916dc15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a41ef049aab400d95175eec9fa916dc15">prolong_lagrange</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range)</td></tr>
<tr class="separator:a41ef049aab400d95175eec9fa916dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08c25274fd4dd387590da5f9087f4ea"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aa08c25274fd4dd387590da5f9087f4ea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;<a class="el" href="a00158.html">is_cg_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aa08c25274fd4dd387590da5f9087f4ea">prolong</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:aa08c25274fd4dd387590da5f9087f4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af392b611b527d3309b23f902cae6bf4b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:af392b611b527d3309b23f902cae6bf4b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak" />
&lt; XT::Grid::is_layer<br class="typebreak" />
&lt; GridLayerType &gt;::value <br class="typebreak" />
&amp;&amp;!<a class="el" href="a00158.html">is_cg_space</a>&lt; RangeSpaceType &gt;<br class="typebreak" />
::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#af392b611b527d3309b23f902cae6bf4b">prolong</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:af392b611b527d3309b23f902cae6bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a00158.html">is_cg_space</a><br class="typebreak" />
&lt; RangeSpaceType &gt;::value, <br class="typebreak" />
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5b3045aa4dc67c8c6aa40604468a8ec7">prolong</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857b2b6325e4bf58234495716f241819"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a857b2b6325e4bf58234495716f241819"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="a00158.html">is_cg_space</a><br class="typebreak" />
&lt; RangeSpaceType &gt;::value, <br class="typebreak" />
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a857b2b6325e4bf58234495716f241819">prolong</a> (const <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00088.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a857b2b6325e4bf58234495716f241819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memTemplParams" colspan="2">template&lt;class R , size_t r, size_t rC, class GL &gt; </td></tr>
<tr class="memitem:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">FvSpace</a>&lt; GL, R, r, rC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a5bd5ee218bea07115ecafce8f0d24a65">make_fv_space</a> (const GL &amp;grid_layer)</td></tr>
<tr class="separator:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memTemplParams" colspan="2">template&lt;class R , size_t r, class GL &gt; </td></tr>
<tr class="memitem:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00135.html">FvSpace</a>&lt; GL, R, r, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#afefce99b2e71a9fe2b8ba379beeb268d">make_fv_space</a> (const GL &amp;grid_layer)</td></tr>
<tr class="separator:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97681edcb4a4c94f2c542ca834983e"><td class="memTemplParams" colspan="2">template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </td></tr>
<tr class="memitem:aaf97681edcb4a4c94f2c542ca834983e"><td class="memTemplItemLeft" align="right" valign="top">Traits::GridLayerType::template <br class="typebreak" />
Codim&lt; codim &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#aaf97681edcb4a4c94f2c542ca834983e">begin</a> (const <a class="el" href="a00138.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;space)</td></tr>
<tr class="separator:aaf97681edcb4a4c94f2c542ca834983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ad5da890a94341a2a4c8ba68416a26"><td class="memTemplParams" colspan="2">template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </td></tr>
<tr class="memitem:a85ad5da890a94341a2a4c8ba68416a26"><td class="memTemplItemLeft" align="right" valign="top">Traits::GridLayerType::template <br class="typebreak" />
Codim&lt; codim &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00646.html#a85ad5da890a94341a2a4c8ba68416a26">end</a> (const <a class="el" href="a00138.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;space)</td></tr>
<tr class="separator:a85ad5da890a94341a2a4c8ba68416a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a37fb8b6a35c3b20bf579f814239315ae"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a37fb8b6a35c3b20bf579f814239315ae">default_cg_backend</a> = <a class="el" href="a00646.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td></tr>
<tr class="separator:a37fb8b6a35c3b20bf579f814239315ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f51ae51b9d4e6763745a95fe0e52d8"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a30f51ae51b9d4e6763745a95fe0e52d8">default_dg_backend</a> = <a class="el" href="a00646.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td></tr>
<tr class="separator:a30f51ae51b9d4e6763745a95fe0e52d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486607c0fc12b5da5bc46c20300b6dae"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00646.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td></tr>
<tr class="separator:a486607c0fc12b5da5bc46c20300b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="afd9e79bf2e05d76e877c835fa352f045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Dune::GDT::Backends</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afd9e79bf2e05d76e877c835fa352f045a411f822017e8c2a440ad181acfe50efb"></a>fem&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afd9e79bf2e05d76e877c835fa352f045a0eaa46c12c8190dcb4e4b46838220683"></a>functions&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b"></a>gdt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afd9e79bf2e05d76e877c835fa352f045a7b681413230ed55022fb3b2e62a300c4"></a>pdelab&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a09f2467105da4217b0ff3bb2e4790c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a09f2467105da4217b0ff3bb2e4790c7e">Dune::GDT::ChoosePattern</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a09f2467105da4217b0ff3bb2e4790c7ea210ab9e731c9c36c2c38db15c28a8d1c"></a>volume&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a09f2467105da4217b0ff3bb2e4790c7ead5ca322453f2986b752e58b11af83d96"></a>face&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a09f2467105da4217b0ff3bb2e4790c7eab68d75779ad98669ad5d654fe30a5827"></a>face_and_volume&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3c443ca2e487b92fa4980cd2730b630a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a3c443ca2e487b92fa4980cd2730b630a">Dune::GDT::ChooseSpaceBackend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3c443ca2e487b92fa4980cd2730b630aa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a7d8c92722e087cefba1ac46ec1fa76f0">Dune::GDT::NumericalFluxes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0a9399d693b7ac38875e19f1c38c4e4439"></a>godunov&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0a11abd4bf1bf2ac68ae9c63f0d9c72a5c"></a>godunov_with_reconstruction&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0a088da8a28ff265eb3b7e18ae1fc24274"></a>laxfriedrichs&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0aa97df7b1900b45631de1ed54602a398d"></a>laxfriedrichs_with_reconstruction&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0aa5aea357904deb91ca3777416848e6b0"></a>local_laxfriedrichs&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d8c92722e087cefba1ac46ec1fa76f0a0fcd1a75f10e9072fc5acce97ac9d3ab"></a>local_laxfriedrichs_with_reconstruction&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5a9b3478d77a16697bf06fa3f949e0fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a5a9b3478d77a16697bf06fa3f949e0fa">Dune::GDT::RosenbrockTimeStepperMethods</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5a9b3478d77a16697bf06fa3f949e0faaefc42475d5c88b4e9d7e08dfeda6ef8b"></a>GRK4A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5a9b3478d77a16697bf06fa3f949e0faa9ed047981c608fb1716e2edee87aa5fc"></a>GRK4T&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5a9b3478d77a16697bf06fa3f949e0faa795f3202b17cb6bc3d4b771d8c6c9eaf"></a>other&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af68dfb986d335b9416add6ef64dfad58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#af68dfb986d335b9416add6ef64dfad58">Dune::GDT::SlopeLimiters</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af68dfb986d335b9416add6ef64dfad58adbc1048da08be92092fbaf26e4561b4d"></a>minmod&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af68dfb986d335b9416add6ef64dfad58ad6fd0924e324f50669ae0295adf59567"></a>mc&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af68dfb986d335b9416add6ef64dfad58adbd796f5b863bc36af8381e5e641ce0e"></a>superbee&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af68dfb986d335b9416add6ef64dfad58a358f8b55910c75c446a7f3418fa87362"></a>no_slope&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">Dune::GDT::SpaceType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a6e9cf3eef65da697796cf33f27eb0f57"></a>cg&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92ab671d14735bdfcc6cf3ed3d691f5ebf4"></a>block_cg&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a2f7e54fe9de9db73067f562bc22d6eae"></a>dg&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a84fcd17e01407bf423248970c680b91c"></a>block_dg&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a3c77f4029be2e609c22bba665f13b101"></a>fv&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92aad8ab1291b6657e98fc69a27f5504619"></a>block_fv&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a822050d9ae3c47f54bee71b85fce1487"></a>rt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1dc558b2ff4b8e95434d41c4e51f6b92a4d8e6751d2f29f14859df8194924ef6c"></a>block_rt&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00646.html#a0a7e45c07c804e026c31fb0b86b7eb69">Dune::GDT::TimeStepperMethods</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69a6715245f54e8e2e94ddb3a731ccbdf10"></a>bogacki_shampine&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69a696a706c4054d122f1275e54d1bc69c0"></a>dormand_prince&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69ac97e4d5c331a2936e04feb034fc4f787"></a>adaptive_rungekutta_other&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69ad8334dcb1e9c0f73386322960f66ace4"></a>explicit_euler&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69a4bc67bde753aa72be3f0cab932ff12a8"></a>explicit_rungekutta_second_order_ssp&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69a0e84aa0f9a2d7d6b364450c7a66cd9a0"></a>explicit_rungekutta_third_order_ssp&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69ab3986d1a2cb34285ab615a07d9b2e8e1"></a>explicit_rungekutta_classic_fourth_order&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0a7e45c07c804e026c31fb0b86b7eb69a3c2eeed127c2d2355fef6aaeaeac5012"></a>explicit_rungekutta_other&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaf97681edcb4a4c94f2c542ca834983e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::GridLayerType::template Codim&lt;codim&gt;::Iterator Dune::GDT::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00138.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a85ad5da890a94341a2a4c8ba68416a26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::GridLayerType::template Codim&lt;codim&gt;::Iterator Dune::GDT::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00138.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b9c4a6f7b668a0b5d89f4f02d9f2257"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; Dune::GDT::make_const_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.constdiscretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abebd2ad3553f76c53794b395f15d276e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a00070.html">DarcyOperator</a>&lt;G, F&gt; &gt; Dune::GDT::make_darcy </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ef1828dbb87ea7925b06e2fb3592981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method m, class GL , class DF , class DT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00083.html">DiffusiveFluxReconstructionOperator</a>&lt;GL, DF, DT, m&gt; Dune::GDT::make_diffusive_flux_reconstruction_operator </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DF &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6598655545d02249af38a6508ea0681b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt;::type Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d3e19a85ebe5c1fbbc4b77437af843c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt;::type Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a824112d0ae2d504cb60bf725b0b52811"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used like</p><div class="fragment"><div class="line"><span class="keyword">auto</span> discrete_function = make_discrete_function&lt;VectorType&gt;(space);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a39dd434250d655456533847e0fd24550"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6b60716df2a7ff51cc279cefd611be4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a0e7e5137ef012766008a318adffd50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d7ac26de7ce19c933a4961092550982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0abcf8a0c7289b894ad73c92ec1aa235"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00109.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe374821da426a5bab4966631dfb33be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor, tensor, boundary_info, space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a723ae048998935420493a23ee5ea991e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                              tensor,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a27716e9a50252e78dfbd00882f043510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor, tensor, boundary_info, space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a731877def65722027447923a18bfe442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                              tensor,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              space,</div>
<div class="line">                                                                                              grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0020b01053f44190ce800c02c652c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor,</div>
<div class="line">                                                         tensor,</div>
<div class="line">                                                         boundary_info,</div>
<div class="line">                                                         range_space,</div>
<div class="line">                                                         source_space,</div>
<div class="line">                                                         grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aaa5d861f8a59da22b6c952478fe8a3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                              tensor,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              range_space,</div>
<div class="line">                                                                                              source_space,</div>
<div class="line">                                                                                              grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ae48a8f11e994cb65b886bfd653202a76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="aa185548adae9af94131880d62bbabc7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                  tensor,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad88e606467a37be4814415340f0e730c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="aa50f1b52002d4f069041329ad968ebc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                  tensor,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  space,</div>
<div class="line">                                                                                  grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a11326936be89261963fcc56f41c15462"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used). </p>

</div>
</div>
<a class="anchor" id="a8ef7bbeba344f2badd87c6eb96677e3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div>
<div class="line">                                                                                  tensor,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  range_space,</div>
<div class="line">                                                                                  source_space,</div>
<div class="line">                                                                                  grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac1687b0deb307fedd89aa3ce0420443f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion, boundary_info, space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a244d38839d3e1f19883cdd2b1dd07f3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d7d95d7700b45a8690ba2bc6a8bb020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion, boundary_info, space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e1154218ae80f409ab597655b27e3ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              space,</div>
<div class="line">                                                                                              grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe0640b34f33baafaadb61e440d80a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion,</div>
<div class="line">                                                         boundary_info,</div>
<div class="line">                                                         range_space,</div>
<div class="line">                                                         source_space,</div>
<div class="line">                                                         grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac305bd91061a17898645ef78e47ad11f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                              boundary_info,</div>
<div class="line">                                                                                              range_space,</div>
<div class="line">                                                                                              source_space,</div>
<div class="line">                                                                                              grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a19aae1548e2aaa5c4ad71b6a72466a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="aa819bbf4e4799bf4501031a635645b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ccb6c2d56014a31dfa7f96fc6358919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="a1f5008a3fbbd914460f557f656d83328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  space,</div>
<div class="line">                                                                                  grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a26a1a51d0e80b2681d20c0f1b5b8bd94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, <a class="el" href="a00652.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used). </p>

</div>
</div>
<a class="anchor" id="a1f8f8f71e1f1d2e056507159a06a4dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00110.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div>
<div class="line">                                                                                  boundary_info,</div>
<div class="line">                                                                                  matrix,</div>
<div class="line">                                                                                  range_space,</div>
<div class="line">                                                                                  source_space,</div>
<div class="line">                                                                                  grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a084a763666c2ec7e18e1d161bf060a63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00111.html">EllipticLocalizableProduct</a>&lt;DiffusionType, void, GridLayerType, RangeType, SourceType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html">EllipticLocalizableProduct</a>, especially for the role of diffusion. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fa3248c4c2349d26b6ebdd92c57599c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00111.html">EllipticLocalizableProduct</a>&lt;DiffusionFactorType, DiffusionTensorType, GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html">EllipticLocalizableProduct</a>, especially for the role of diffusion_factor and diffusion_tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e5ac11789f5a6a20eb9c4c591f7590f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std:: unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b417cfe37ddd413a1a88f8d4832b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e8de41cd99705c54a463ff8979abb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, range_space, source_space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac79ebd71eca30efd87b6f57c0f49f600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std:: unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="a6f78e3513c8c8445e9b7065419041030"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="ad4f6e182a9cecb5d8c8f9bb6da507e36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator. </p>

</div>
</div>
<a class="anchor" id="a645898ad9e18b9ee082694eb129be6e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a59f7a9e88dc8fb3ea1bc7b5847d148e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b492fe167180d66b57155a9c4efc20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, range_space, source_space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b224a5d8038ccad232f22cd4f94392c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="ad25dd39c95e458ac83ee12b6f50b105d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="a4b601eea0442b605302ad79f18056d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00112.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given). </p>

</div>
</div>
<a class="anchor" id="a6d25b2d08b99737792191ea9dc56b529"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class DiffusionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00113.html">EllipticOperator</a>&lt;DiffusionType, void, GridLayerType, typename DiffusionType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1757fab0086f1e2e9767645fc23fd9c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class DiffusionFactorType , class DiffusionTensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00113.html">EllipticOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, GridLayerType, typename DiffusionFactorType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bd5ee218bea07115ecafce8f0d24a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , size_t r, size_t rC, class GL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">FvSpace</a>&lt;GL, R, r, rC&gt; Dune::GDT::make_fv_space </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afefce99b2e71a9fe2b8ba379beeb268d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , size_t r, class GL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00135.html">FvSpace</a>&lt;GL, R, r, 1&gt; Dune::GDT::make_fv_space </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6adbf86b5d86a023e2e8e93cbcbc6d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00219.html">L2GlobalProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ada5f8915864e0699caf07017b3f0bbd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00219.html">L2GlobalProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dc211dfec7d3c46b5d59c7b1403bdf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00220.html">L2GlobalProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a639a3d279612f1a236d81216fb81a7b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00222.html">L2GlobalProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_global_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa18eac69cefdad4ac3eb8063a23a2b41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00222.html">L2GlobalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a564a3610e71d59f474af2dfd988fc868"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00223.html">L2GlobalProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_global_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad13b49c6523f019648edfa58bd969a01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae89d3d1d139a3701a04009dd8f4f1b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ea2165b905a0ab10151dc18ed738a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f4d4bd089dc21a0aa4b6c1ca31147cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa88a95427edfbc6c6b5c870231eaad13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36902d54169c4fe3b79ed285b09bfe02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaeb52cbd5b060759f9de394e39eab0f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a27a02f887f4a3f3a70d9345e06985b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3641c0872fda34a50acf5d8e239b7255"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a531cfd940b7c4bee0e93c711b84b23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d1e7607ac4a7de8b39221a64f6a8911"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab74f9b73968b13fde92ca858e2580c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00218.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a24db0c68e2159dc885e41c182ab1ffaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00225.html">L2LocalizableProduct</a>&lt;GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_l2_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00225.html">L2LocalizableProduct</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6df3ece6d2703ff6bedf3420c5e3a95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a19320cc6468677248b8ab4eed3b3de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a59bd3e4a730d2e05605abbee7bcd9baf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;:: type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(range_space, source_space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aaca65e541579ace42958d0248e85dc8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="a3aa7d90d3f800e69ceb9956818a7ab29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="aa8805736f27ea9f91b346e93251ffcaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00232.html">L2MatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;:: type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator. </p>

</div>
</div>
<a class="anchor" id="aaa8d9d3c704dad52fe1215c40ce7755e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00233.html">L2Operator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb37c26aebc4f0de53587319f55a017b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00235.html">L2ProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1fda08c8477972bb5135da2513518dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00235.html">L2ProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53207d499f1a26958db4d5efb6ba6bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00237.html">L2ProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7a059579e9a8e50834a6763bdc62ab4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00239.html">L2ProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SS, SV&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RS, RV&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3431709faed7b4fc53cc909140f9a96b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a00239.html">L2ProlongationLocalizableOperator</a>&lt;typename RS::GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SS, SV&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RS, RV&gt; &gt; &gt; Dune::GDT::make_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66f74bd1b2248a25d0c380d3464f4724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00241.html">L2ProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe8c4f6526fc7650a166503429052bd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00243.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4789d283e11ff2337c91378c073139d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00243.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac41f06438b689a0443f35c3fb314021c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00243.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5efe5fd8a990d2670302e0454aec822f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00243.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac883c6de02a9d52128dd3b2003883c25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00244.html">LagrangeProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef6917e0c8e9271cd8993ecb18b551ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00244.html">LagrangeProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6bd9942fa032bb572db38180e9602c4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00245.html">LagrangeProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae76ee38cc1a53992ee3902192ed7748b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00247.html">LagrangeProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_lagrange_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab17ad63fd7b207e96711ddf24b5a3b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a00247.html">LagrangeProlongationLocalizableOperator</a>&lt;typename RangeSpaceType::GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; Dune::GDT::make_lagrange_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab39a31d2d051596296e00ceea186232b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00248.html">LagrangeProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_lagrange_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a98af1b0075368ee591155362a770327e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00250.html">LaplaceLocalizableProduct</a>&lt;GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00250.html">LaplaceLocalizableProduct</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac58267637036be6ee37f0e48d1162ab0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ab45e793f951853fe2462720fbdb0efe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a187c2435913bbaefd577916a044eeaff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(range_space, source_space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a73a1412fbe2dd31bb9c7c48f943fecb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="aa2f40f54739e0f5758158c62af274630"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="a5bfd627da92f1aa70984f784203f0f57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00251.html">LaplaceMatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator. </p>

</div>
</div>
<a class="anchor" id="a614c77184eaff56d640da03fc408d27b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00252.html">LaplaceOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af7bc202d2e4d8bf8790417229f396a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00226.html">L2LocalProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff9a11474b9b3aba686860d733a88d1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00226.html">L2LocalProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a72af8b84996d16c4b31bbceaceefca6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00227.html">L2LocalProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5266097dd59841669c823330c03b5771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00229.html">L2LocalProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_local_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a610d51db21eef9fa649d8e6208639a77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00229.html">L2LocalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00063.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00088.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae259c74e23bd82ed2bdb7bc190df8093"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00230.html">L2LocalProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_local_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f639f3b2734291a3ab3c17c8894fdcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class RangeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a00087.html">DirichletProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, RangeType&gt; &gt; Dune::GDT::make_localizable_dirichlet_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b041e261527d21bda30b8a0cfd22e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00421.html">WeightedL2LocalizableProduct</a>&lt;WeightFunctionType, GridLayerType, RangeType, SourceType&gt; &gt; &gt;:: type Dune::GDT::make_weighted_l2_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00421.html">WeightedL2LocalizableProduct</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94c370bc5da752091bf363382ccad66f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, space);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a419d49e35616d30a21a82601a8358d85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a8790f22db7ca14a73ae19e9993742320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, range_space, source_space, grid_layer);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c65510f0494c44231137be7b61eb712"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a class="anchor" id="a7fa80f01415bd014fdc5dd79dd286edc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpaceType &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (source and range space are given by space). </p>

</div>
</div>
<a class="anchor" id="af9ae6d54b1de546de981980dcc26c961"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00422.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator. </p>

</div>
</div>
<a class="anchor" id="ac54f2e7c92b7268e11b82ccea2407271"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class WeightFunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a00423.html">WeightedL2Operator</a>&lt;WeightFunctionType, GridLayerType, typename WeightFunctionType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4435bc1a91769f295e13244775d9366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::GDT::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstLocalDoFVector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab28f3c4b54b4fb8206d8b24f2f2c1e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00158.html">is_cg_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6930f61566d99bf1e2ad1a1ea8ebdda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; !<a class="el" href="a00158.html">is_cg_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2246f50ebf840a99127b39c957faadf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00158.html">is_cg_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add15cc27cd3d12bd7a1e30e5bf37224f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; !<a class="el" href="a00158.html">is_cg_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c1a4243d386c3a6575feb6fe3fb2109"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_l2 </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a86840014ba403445a5c8d9411621faf9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_l2 </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41c75b8be21f9395bd635da5aa2ae169"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_lagrange </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab13df6c545215f77354ce5e7195100ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a00198.html">is_space</a>&lt;<a class="el" href="a00646.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_lagrange </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; SpaceType, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa08c25274fd4dd387590da5f9087f4ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a00158.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af392b611b527d3309b23f902cae6bf4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; !<a class="el" href="a00158.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b3045aa4dc67c8c6aa40604468a8ec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a00158.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a857b2b6325e4bf58234495716f241819"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="a00158.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fab99cb387849e714c05a0d2b27c197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, void&gt;::type Dune::GDT::prolong_l2 </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a961b32a7982c5bf781045fbfa0eb9aab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::GDT::prolong_l2 </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d568aa7a7ad273010bb8431fe418d8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, void&gt;::type Dune::GDT::prolong_lagrange </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41ef049aab400d95175eec9fa916dc15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::GDT::prolong_lagrange </td>
          <td>(</td>
          <td class="paramtype">const ConstDiscreteFunction&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a37fb8b6a35c3b20bf579f814239315ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_cg_backend = <a class="el" href="a00646.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a30f51ae51b9d4e6763745a95fe0e52d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_dg_backend = <a class="el" href="a00646.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a486607c0fc12b5da5bc46c20300b6dae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00646.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_space_backend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    Backends::gdt</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 8 2017 19:09:41 for dune-gdt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
