<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-gdt: Dune::GDT Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-gdt
   &#160;<span id="projectnumber">0.3-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00230.html">Dune</a></li><li class="navelem"><a class="el" href="a00231.html">GDT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dune::GDT Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00237"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">BaseFunctionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00232"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00233"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">LocalEllipticIpdgIntegrands</a></td></tr>
<tr class="memdesc:a00233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains local integrands for the family of interior penalty discontinuous Galerkin (IPDG) discretization schemes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00235"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">LocalSipdgIntegrands</a></td></tr>
<tr class="memdesc:a00235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains local evaluations for the symmetric interior penalty discontinuous Galerkin (SIPDG) discretization. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02890.html">AdaptiveRungeKuttaTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using adaptive Runge Kutta methods.  <a href="a02890.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01886.html">AdvectionForceOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01894.html">AdvectionGodunovOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01902.html">AdvectionKineticOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01910.html">AdvectionLaxFriedrichsOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01918.html">AdvectionLaxWendroffOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01842.html">AdvectionLocalizableDefault</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01926.html">AdvectionMustaOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01854.html">AdvectionOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01978.html">AdvectionRhsOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02346.html">BaseFunctionSetInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of this interface is just to be used for template matching and to allow for access to the backend. All other functionality is enforced by XT::Functions::LocalfunctionSetInterface.  <a href="a02346.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02402.html">BlockCgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02530.html">BlockDgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02598.html">BlockFvSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02110.html">BlockMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02830.html">BlockRtSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02102.html">BlockSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02386.html">CgSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02390.html">CgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00890.html">ConstDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01102.html">ConstLocalDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01110.html">ConstLocalDoFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02406.html">ConstraintsInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP interface for all implementations of constraints.  <a href="a02406.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00994.html">ContainerBasedStationaryDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02378.html">ContinuousLagrangeSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01938.html">ConvexHullLocalRealizabilityLimiter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01786.html">DarcyOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02434.html">DataEntityGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02430.html">DataGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02714.html">DefaultProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02730.html">DefaultProductMapperFromTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02734.html">DefaultProductMapperFromTuple&lt; GridLayerImp, std::tuple&lt; MapperTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02746.html">DefaultProductSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02502.html">DgSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02518.html">DgSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02950.html">DiagonallyImplicitRungeKuttaTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using diagonally implicit Runge Kutta methods.  <a href="a02950.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01830.html">DiffusiveFluxReconstructionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01834.html">DiffusiveFluxReconstructionOperator&lt; GridLayerType, LocalizableFunctionType, void, method &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02410.html">DirichletConstraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02166.html">DirichletProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02474.html">DiscontinuousLagrangeSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02498.html">DiscontinuousLagrangeSpace&lt; GL, 0, R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00922.html">DiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00886.html">DiscreteFunctionDataHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02458.html">DisjointPartitioningDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GatherScatter data handle for creating a disjoint DOF partitioning.  <a href="a02458.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02454.html">DisjointPartitioningGatherScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GatherScatter functor for creating a disjoint DOF partitioning.  <a href="a02454.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02738.html">DofCommunicationChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02418.html">DofDataCommunicationDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01810.html">EllipticLocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01814.html">EllipticMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01818.html">EllipticOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02422.html">EntityDataCommunicationDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01118.html">EntropyBasedLocalFlux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01134.html">EntropyBasedLocalFlux&lt; Hyperbolic::Problems::HatFunctions&lt; typename U::DomainFieldType, 1, typename U::RangeFieldType, U::dimRange, 1, 1 &gt;, GridLayerImp, U, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02918.html">ExplicitRungeKuttaTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using Runge Kutta methods.  <a href="a02918.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02634.html">FixedOrderMultipleCodimMultipleGeomTypeMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02642.html">FixedOrderScalarDiscontinuousMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01146.html">ForceLocalDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for Dirichlet boundary intersections.  <a href="a01146.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01142.html">ForceLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01142.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02930.html">FractionalTimeStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01050.html">FunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00998.html">FvDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02670.html">FvMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02694.html">FvMapper&lt; GridLayerImp, 1, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02690.html">FvMapper&lt; GridLayerImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02674.html">FvProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02698.html">FvProductMapper&lt; GridLayerImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02562.html">FvProductSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02570.html">FvProductSpace&lt; GridLayerImp, RangeFieldImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02586.html">FvProductSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02534.html">FvSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02542.html">FvSpace&lt; GridLayerImp, RangeFieldImp, rangeDim, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02546.html">FvSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02574.html">FvSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02742.html">GenericParallelHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02450.html">GhostDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data handle for marking ghost DOFs.  <a href="a02450.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02446.html">GhostGatherScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GatherScatter functor for marking ghost DOFs.  <a href="a02446.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01162.html">GodunovLocalDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Godunov flux evaluation for Dirichlet boundary intersections.  <a href="a01162.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01158.html">GodunovLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01158.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00974.html">HyperbolicFvDefaultDiscretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03078.html">is_binary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03082.html">is_binary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03062.html">is_binary_volume_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03066.html">is_binary_volume_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03030.html">is_cg_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03034.html">is_cg_space&lt; S, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03038.html">is_cg_space&lt; S, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00930.html">is_const_discrete_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00934.html">is_const_discrete_function&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02510.html">is_dg_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02514.html">is_dg_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00938.html">is_discrete_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00942.html">is_discrete_function&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02554.html">is_fv_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02558.html">is_fv_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01714.html">is_local_boundary_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01710.html">is_local_coupling_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01214.html">is_local_numerical_boundary_flux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01210.html">is_local_numerical_coupling_flux</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01706.html">is_local_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03102.html">is_localizable_product</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03106.html">is_localizable_product&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03110.html">is_matrix_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03114.html">is_matrix_operator&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03094.html">is_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03098.html">is_operator&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03014.html">is_product_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03018.html">is_product_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03086.html">is_quaternary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03090.html">is_quaternary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03022.html">is_restricted_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03026.html">is_restricted_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03042.html">is_rt_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03046.html">is_rt_space&lt; S, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03050.html">is_rt_space&lt; S, true, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03006.html">is_space</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03010.html">is_space&lt; S, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01006.html">is_stationary_discretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01010.html">is_stationary_discretization&lt; D, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03070.html">is_unary_face_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03074.html">is_unary_face_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03054.html">is_unary_volume_integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03058.html">is_unary_volume_integrand&lt; T, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02706.html">IsProductMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01222.html">KineticLocalNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinetic flux evaluation for Dirichlet boundary intersections.  <a href="a01222.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01218.html">KineticLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinetic flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01218.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01058.html">L2FaceVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02178.html">L2GlobalProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02170.html">L2GlobalProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02262.html">L2GlobalProlongationLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02254.html">L2GlobalProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02022.html">L2LocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02198.html">L2LocalProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02190.html">L2LocalProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02274.html">L2LocalProlongationLocalizableOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out a prolongation (in a localized manner) using a local L2 projection.  <a href="a02274.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02266.html">L2LocalProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02030.html">L2MatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02038.html">L2Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02230.html">L2ProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02210.html">L2ProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02298.html">L2ProlongationLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02278.html">L2ProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01054.html">L2VolumeVectorFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02242.html">LagrangeProjectionLocalizableOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02246.html">LagrangeProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02318.html">LagrangeProlongationLocalizableOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carries out a prolongation (in a localized manner) using a lagrange projection.  <a href="a02318.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02310.html">LagrangeProlongationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02046.html">LaplaceLocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02054.html">LaplaceMatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02062.html">LaplaceOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01246.html">LaxFriedrichsLocalAbsorbingNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for absorbing boundary conditions on boundary intersections.  <a href="a01246.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01242.html">LaxFriedrichsLocalDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for Dirichlet boundary intersections.  <a href="a01242.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01238.html">LaxFriedrichsLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01238.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01278.html">LaxWendroffLocalDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Wendroff flux evaluation for Dirichlet boundary intersections.  <a href="a01278.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01274.html">LaxWendroffLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01274.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02610.html">layer_from_backend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02614.html">layer_from_backend&lt; Backends::gdt &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01646.html">LocalBoundaryFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01666.html">LocalBoundaryIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01090.html">LocalBoundaryOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01690.html">LocalBoundaryOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01086.html">LocalBoundaryTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00802.html">LocalBoundaryTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01702.html">LocalBoundaryTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01642.html">LocalCouplingFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01662.html">LocalCouplingIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01082.html">LocalCouplingOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01686.html">LocalCouplingOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01078.html">LocalCouplingTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00798.html">LocalCouplingTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01698.html">LocalCouplingTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01494.html">LocalDiffusiveFluxEstimateESV2007Integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01506.html">LocalDiffusiveFluxEstimateESV2007Integrand&lt; DiffusionType, DiffusiveFluxType, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02094.html">LocalDiffusiveFluxEstimateStarOS2014Integrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01634.html">LocalDirichletProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01106.html">LocalDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01114.html">LocalDoFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01470.html">LocalEllipticIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an elliptic evaluation.  <a href="a01470.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01098.html">LocalFaceFunctionalAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00810.html">LocalFaceFunctionalAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01326.html">LocalFaceFunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01318.html">LocalFaceIntegralFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01546.html">LocalFaceIntegrandInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for local evaluations that depend on an intersection.  <a href="a01546.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01550.html">LocalFaceIntegrandInterface&lt; Traits, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for unary codim 1 evaluations.  <a href="a01550.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01554.html">LocalFaceIntegrandInterface&lt; Traits, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for binary codim 1 evaluations.  <a href="a01554.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01558.html">LocalFaceIntegrandInterface&lt; Traits, 4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for quaternary codim 1 evaluations.  <a href="a01558.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01598.html">LocalFVProductIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a product evaluation for a finite volume basis.  <a href="a01598.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01510.html">LocalFvRhsIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01514.html">LocalFvRhsJacobianIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01518.html">LocalFvRhsNewtonIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01826.html">LocalizableDiffusiveFluxReconstructionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01782.html">LocalizableOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01766.html">LocalizableProductBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01722.html">LocalL2ProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01734.html">LocalLagrangeProjectionOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01566.html">LocalLambdaBinaryFaceIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01562.html">LocalLambdaBinaryVolumeIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01746.html">LocalLambdaCouplingOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01742.html">LocalLambdaOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01570.html">LocalLambdaQuaternaryFaceIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01574.html">LocalLambdaUnaryVolumeIntegrand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01206.html">LocalNumericalBoundaryFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01202.html">LocalNumericalCouplingFluxInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html">LocalOperatorApplicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01682.html">LocalOperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01074.html">LocalOperatorJacobianAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01594.html">LocalProductIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a product evaluation.  <a href="a01594.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01954.html">LocalReconstructionFvOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02630.html">LocalView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01094.html">LocalVolumeFunctionalAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00806.html">LocalVolumeFunctionalAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01322.html">LocalVolumeFunctionalInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01314.html">LocalVolumeIntegralFunctional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01658.html">LocalVolumeIntegralOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01534.html">LocalVolumeIntegrandInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for local evaluations that depend on a codim 0 entity.  <a href="a01534.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01538.html">LocalVolumeIntegrandInterface&lt; Traits, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for unary codim 0 evaluations.  <a href="a01538.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01542.html">LocalVolumeIntegrandInterface&lt; Traits, 2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for binary codim 0 evaluations.  <a href="a01542.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01066.html">LocalVolumeTwoFormAccumulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00790.html">LocalVolumeTwoFormAccumulatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01062.html">LocalVolumeTwoFormAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00794.html">LocalVolumeTwoFormAssemblerFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01694.html">LocalVolumeTwoFormInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01942.html">LPLocalRealizabilityLimiter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01034.html">mapper_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02702.html">MapperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01990.html">MatrixApplyFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00786.html">MatrixDataHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02962.html">MatrixExponentialTimeStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01758.html">MatrixOperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01986.html">MatrixSolveFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02442.html">MinDataHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02438.html">MinGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01298.html">MustaLocalDirichletNumericalBoundaryFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MUSTA flux evaluation for Dirichlet boundary intersections.  <a href="a01298.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01294.html">MustaLocalNumericalCouplingFlux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lax-Friedrichs flux evaluation for inner intersections and periodic boundary intersections.  <a href="a01294.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01934.html">NonLimitingRealizabilityLimiter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01014.html">operator_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02018.html">OperatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02070.html">OswaldInterpolationOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02710.html">ProductMapperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02626.html">ProductSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01022.html">projection_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01018.html">prolongation_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02774.html">RaviartThomasBasefunctionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02778.html">RaviartThomasSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01946.html">ReconstructedLocalizableFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the map of reconstructed values that fulfills the XT::Functions::LocalizableFunctionInterface.  <a href="a01946.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01882.html">ReconstructionDataHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00946.html">ReinterpretDiscreteFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01030.html">restricted_space_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02126.html">RestrictedMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02134.html">RestrictedSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02162.html">RosenbrockTimeStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stepper using Rosenbrock-type methods.  <a href="a02162.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02814.html">RtSpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02818.html">RtSpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02322.html">ScalarBasefunctionSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02466.html">SharedDOFDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data handle for marking shared DOFs.  <a href="a02466.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02462.html">SharedDOFGatherScatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GatherScatter functor for marking shared DOFs.  <a href="a02462.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01026.html">space_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02426.html">SpaceDataHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02618.html">SpaceInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02470.html">SpaceNeighborDataHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data handle for collecting set of neighboring MPI ranks.  <a href="a02470.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02834.html">SpaceProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02842.html">SpaceProvider&lt; G, layer, SpaceType::block_cg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02850.html">SpaceProvider&lt; G, layer, SpaceType::block_dg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02862.html">SpaceProvider&lt; G, layer, SpaceType::block_fv, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02870.html">SpaceProvider&lt; G, layer, SpaceType::block_rt, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02838.html">SpaceProvider&lt; G, layer, SpaceType::cg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02846.html">SpaceProvider&lt; G, layer, SpaceType::dg, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02854.html">SpaceProvider&lt; G, layer, SpaceType::fv, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02858.html">SpaceProvider&lt; G, layer, SpaceType::product_fv, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02866.html">SpaceProvider&lt; G, layer, SpaceType::rt, backend, p, R, r, rC, g &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00982.html">StationaryContainerBasedDefaultDiscretization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00990.html">StationaryDiscretizationInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02934.html">StrangSplittingTimeStepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00814.html">SystemAssembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02922.html">TimeStepperFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02958.html">TimeStepperInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02926.html">TimeStepperSplittingFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01038.html">VectorFunctionalBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02078.html">WeightedL2LocalizableProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02082.html">WeightedL2MatrixOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02086.html">WeightedL2Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02638.html">ZeroOrderScalarDiscontinuousMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7d8c92722e087cefba1ac46ec1fa76f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0">NumericalFluxes</a> { <br />
&#160;&#160;<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0aae254d63f2381cc183c11594873793e0">NumericalFluxes::force</a>, 
<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0a9399d693b7ac38875e19f1c38c4e4439">NumericalFluxes::godunov</a>, 
<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0a0f43c03a9e7ebc152cbaae416314ad69">NumericalFluxes::kinetic</a>, 
<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0a088da8a28ff265eb3b7e18ae1fc24274">NumericalFluxes::laxfriedrichs</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0a03070545f77a8199923fb2e80550deb2">NumericalFluxes::laxwendroff</a>, 
<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0aa5aea357904deb91ca3777416848e6b0">NumericalFluxes::local_laxfriedrichs</a>, 
<a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0a230d6f2fbb1b2f868241b805b6f837e7">NumericalFluxes::musta</a>
<br />
 }</td></tr>
<tr class="separator:a7d8c92722e087cefba1ac46ec1fa76f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68dfb986d335b9416add6ef64dfad58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58">SlopeLimiters</a> { <a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58adbc1048da08be92092fbaf26e4561b4d">SlopeLimiters::minmod</a>, 
<a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58ad6fd0924e324f50669ae0295adf59567">SlopeLimiters::mc</a>, 
<a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58adbd796f5b863bc36af8381e5e641ce0e">SlopeLimiters::superbee</a>, 
<a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58a358f8b55910c75c446a7f3418fa87362">SlopeLimiters::no_slope</a>
 }</td></tr>
<tr class="separator:af68dfb986d335b9416add6ef64dfad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9b3478d77a16697bf06fa3f949e0fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a5a9b3478d77a16697bf06fa3f949e0fa">RosenbrockTimeStepperMethods</a> { <a class="el" href="a00231.html#a5a9b3478d77a16697bf06fa3f949e0faaefc42475d5c88b4e9d7e08dfeda6ef8b">RosenbrockTimeStepperMethods::GRK4A</a>, 
<a class="el" href="a00231.html#a5a9b3478d77a16697bf06fa3f949e0faa9ed047981c608fb1716e2edee87aa5fc">RosenbrockTimeStepperMethods::GRK4T</a>, 
<a class="el" href="a00231.html#a5a9b3478d77a16697bf06fa3f949e0faa795f3202b17cb6bc3d4b771d8c6c9eaf">RosenbrockTimeStepperMethods::other</a>
 }</td></tr>
<tr class="separator:a5a9b3478d77a16697bf06fa3f949e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e79bf2e05d76e877c835fa352f045"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> { <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a>
 }</td></tr>
<tr class="separator:afd9e79bf2e05d76e877c835fa352f045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc558b2ff4b8e95434d41c4e51f6b92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> { <br />
&#160;&#160;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a6e9cf3eef65da697796cf33f27eb0f57">SpaceType::cg</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92ab671d14735bdfcc6cf3ed3d691f5ebf4">SpaceType::block_cg</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a2f7e54fe9de9db73067f562bc22d6eae">SpaceType::dg</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a84fcd17e01407bf423248970c680b91c">SpaceType::block_dg</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a3c77f4029be2e609c22bba665f13b101">SpaceType::fv</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a8423b29b9be45caa628e4d0ade957cb1">SpaceType::product_fv</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92aad8ab1291b6657e98fc69a27f5504619">SpaceType::block_fv</a>, 
<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a822050d9ae3c47f54bee71b85fce1487">SpaceType::rt</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92a4d8e6751d2f29f14859df8194924ef6c">SpaceType::block_rt</a>
<br />
 }</td></tr>
<tr class="separator:a1dc558b2ff4b8e95434d41c4e51f6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f2467105da4217b0ff3bb2e4790c7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a09f2467105da4217b0ff3bb2e4790c7e">ChoosePattern</a> { <a class="el" href="a00231.html#a09f2467105da4217b0ff3bb2e4790c7ea210ab9e731c9c36c2c38db15c28a8d1c">ChoosePattern::volume</a>, 
<a class="el" href="a00231.html#a09f2467105da4217b0ff3bb2e4790c7ead5ca322453f2986b752e58b11af83d96">ChoosePattern::face</a>, 
<a class="el" href="a00231.html#a09f2467105da4217b0ff3bb2e4790c7eab68d75779ad98669ad5d654fe30a5827">ChoosePattern::face_and_volume</a>
 }</td></tr>
<tr class="separator:a09f2467105da4217b0ff3bb2e4790c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7e45c07c804e026c31fb0b86b7eb69"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69">TimeStepperMethods</a> { <br />
&#160;&#160;<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a6715245f54e8e2e94ddb3a731ccbdf10">TimeStepperMethods::bogacki_shampine</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a696a706c4054d122f1275e54d1bc69c0">TimeStepperMethods::dormand_prince</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ac97e4d5c331a2936e04feb034fc4f787">TimeStepperMethods::adaptive_rungekutta_other</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ad8334dcb1e9c0f73386322960f66ace4">TimeStepperMethods::explicit_euler</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a4bc67bde753aa72be3f0cab932ff12a8">TimeStepperMethods::explicit_rungekutta_second_order_ssp</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a0e84aa0f9a2d7d6b364450c7a66cd9a0">TimeStepperMethods::explicit_rungekutta_third_order_ssp</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ab3986d1a2cb34285ab615a07d9b2e8e1">TimeStepperMethods::explicit_rungekutta_classic_fourth_order</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a3c2eeed127c2d2355fef6aaeaeac5012">TimeStepperMethods::explicit_rungekutta_other</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ae9e3a7543796e9e0256a12f6dd5d4ecd">TimeStepperMethods::implicit_euler</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ab84a8ef36b79ee75983435cd9b3de48c">TimeStepperMethods::implicit_midpoint</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a73c714ae3da44202127a7306c3efdebe">TimeStepperMethods::trapezoidal_rule</a>, 
<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69a96b211390682c9d151b6579c4611ebc0">TimeStepperMethods::diagonally_implicit_other</a>, 
<br />
&#160;&#160;<a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69ae027c8edf587abe07bb3a0a3bfa154b6">TimeStepperMethods::matrix_exponential</a>
<br />
 }</td></tr>
<tr class="separator:a0a7e45c07c804e026c31fb0b86b7eb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7583ef0313f2a3c3aa79768aa757b28"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#ad7583ef0313f2a3c3aa79768aa757b28">TimeStepperSplittingMethods</a> { <a class="el" href="a00231.html#ad7583ef0313f2a3c3aa79768aa757b28a0ba4dc47ff49a8e6fb4d5ca1d6ae8518">TimeStepperSplittingMethods::fractional_step</a>, 
<a class="el" href="a00231.html#ad7583ef0313f2a3c3aa79768aa757b28a09393b89e071daa6711ae0a264f34398">TimeStepperSplittingMethods::strang</a>
 }</td></tr>
<tr class="separator:ad7583ef0313f2a3c3aa79768aa757b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6b9c4a6f7b668a0b5d89f4f02d9f2257">make_const_discrete_function</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const VectorType &amp;vector, const std::string nm=&quot;gdt.constdiscretefunction&quot;)</td></tr>
<tr class="separator:a6b9c4a6f7b668a0b5d89f4f02d9f2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6598655545d02249af38a6508ea0681b"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a6598655545d02249af38a6508ea0681b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6598655545d02249af38a6508ea0681b">make_discrete_function</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, VectorType &amp;vector, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a6598655545d02249af38a6508ea0681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memTemplParams" colspan="2">template&lt;class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a7d3e19a85ebe5c1fbbc4b77437af843c">make_discrete_function</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, VectorType &amp;&amp;vector, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a7d3e19a85ebe5c1fbbc4b77437af843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824112d0ae2d504cb60bf725b0b52811"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a824112d0ae2d504cb60bf725b0b52811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a824112d0ae2d504cb60bf725b0b52811">make_discrete_function</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const std::string nm=&quot;gdt.discretefunction&quot;)</td></tr>
<tr class="separator:a824112d0ae2d504cb60bf725b0b52811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dd434250d655456533847e0fd24550"><td class="memTemplParams" colspan="2">template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a39dd434250d655456533847e0fd24550"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DirichletType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt; DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a39dd434250d655456533847e0fd24550">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a39dd434250d655456533847e0fd24550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b60716df2a7ff51cc279cefd611be4"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:ae6b60716df2a7ff51cc279cefd611be4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DirichletType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt; DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ae6b60716df2a7ff51cc279cefd611be4">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ae6b60716df2a7ff51cc279cefd611be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e7e5137ef012766008a318adffd50"><td class="memTemplParams" colspan="2">template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a6a0e7e5137ef012766008a318adffd50"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DirichletType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt; DirichletType, DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6a0e7e5137ef012766008a318adffd50">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a6a0e7e5137ef012766008a318adffd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ac26de7ce19c933a4961092550982"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a1d7ac26de7ce19c933a4961092550982"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DirichletType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt; DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1d7ac26de7ce19c933a4961092550982">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1d7ac26de7ce19c933a4961092550982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DirichletType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt; DirichletType, DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a0abcf8a0c7289b894ad73c92ec1aa235">make_elliptic_ipdg_dirichlet_vector_functional</a> (const DirichletType &amp;dirichlet, const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:a0abcf8a0c7289b894ad73c92ec1aa235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8c4f6526fc7650a166503429052bd3"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:abe8c4f6526fc7650a166503429052bd3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abe8c4f6526fc7650a166503429052bd3">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:abe8c4f6526fc7650a166503429052bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4789d283e11ff2337c91378c073139d"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:af4789d283e11ff2337c91378c073139d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#af4789d283e11ff2337c91378c073139d">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:af4789d283e11ff2337c91378c073139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f06438b689a0443f35c3fb314021c"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac41f06438b689a0443f35c3fb314021c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac41f06438b689a0443f35c3fb314021c">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ac41f06438b689a0443f35c3fb314021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efe5fd8a990d2670302e0454aec822f"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5efe5fd8a990d2670302e0454aec822f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5efe5fd8a990d2670302e0454aec822f">make_l2_volume_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a5efe5fd8a990d2670302e0454aec822f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13b49c6523f019648edfa58bd969a01"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:ad13b49c6523f019648edfa58bd969a01"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad13b49c6523f019648edfa58bd969a01">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:ad13b49c6523f019648edfa58bd969a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ae89d3d1d139a3701a04009dd8f4f1b45">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:ae89d3d1d139a3701a04009dd8f4f1b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3ea2165b905a0ab10151dc18ed738a2d">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a3ea2165b905a0ab10151dc18ed738a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1f4d4bd089dc21a0aa4b6c1ca31147cb">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1f4d4bd089dc21a0aa4b6c1ca31147cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88a95427edfbc6c6b5c870231eaad13"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa88a95427edfbc6c6b5c870231eaad13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa88a95427edfbc6c6b5c870231eaad13">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:aa88a95427edfbc6c6b5c870231eaad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36902d54169c4fe3b79ed285b09bfe02"><td class="memTemplParams" colspan="2">template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a36902d54169c4fe3b79ed285b09bfe02"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a36902d54169c4fe3b79ed285b09bfe02">make_l2_face_vector_functional</a> (const FunctionType &amp;function, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a36902d54169c4fe3b79ed285b09bfe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType &gt; </td></tr>
<tr class="memitem:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aaeb52cbd5b060759f9de394e39eab0f4">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="separator:aaeb52cbd5b060759f9de394e39eab0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a27a02f887f4a3f3a70d9345e06985b7a">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a27a02f887f4a3f3a70d9345e06985b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3641c0872fda34a50acf5d8e239b7255"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3641c0872fda34a50acf5d8e239b7255"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3641c0872fda34a50acf5d8e239b7255">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a3641c0872fda34a50acf5d8e239b7255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3a531cfd940b7c4bee0e93c711b84b23">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a3a531cfd940b7c4bee0e93c711b84b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6d1e7607ac4a7de8b39221a64f6a8911">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:a6d1e7607ac4a7de8b39221a64f6a8911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74f9b73968b13fde92ca858e2580c8a"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab74f9b73968b13fde92ca858e2580c8a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; FunctionType &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt; FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab74f9b73968b13fde92ca858e2580c8a">make_l2_face_vector_functional</a> (const FunctionType &amp;function, VectorType &amp;vector, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate, const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *where)</td></tr>
<tr class="separator:ab74f9b73968b13fde92ca858e2580c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4435bc1a91769f295e13244775d9366"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad4435bc1a91769f295e13244775d9366"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad4435bc1a91769f295e13244775d9366">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="a01110.html">ConstLocalDoFVector</a>&lt; V &gt; &amp;vector)</td></tr>
<tr class="separator:ad4435bc1a91769f295e13244775d9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebd2ad3553f76c53794b395f15d276e"><td class="memTemplParams" colspan="2">template&lt;class G , class F &gt; </td></tr>
<tr class="memitem:abebd2ad3553f76c53794b395f15d276e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a01786.html">DarcyOperator</a>&lt; G, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abebd2ad3553f76c53794b395f15d276e">make_darcy</a> (const G &amp;grid_layer, const F &amp;function)</td></tr>
<tr class="separator:abebd2ad3553f76c53794b395f15d276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe374821da426a5bab4966631dfb33be"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:abe374821da426a5bab4966631dfb33be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abe374821da426a5bab4966631dfb33be">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:abe374821da426a5bab4966631dfb33be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#abe374821da426a5bab4966631dfb33be">More...</a><br /></td></tr>
<tr class="separator:abe374821da426a5bab4966631dfb33be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ae048998935420493a23ee5ea991e"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a723ae048998935420493a23ee5ea991e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a723ae048998935420493a23ee5ea991e">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a723ae048998935420493a23ee5ea991e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#a723ae048998935420493a23ee5ea991e">More...</a><br /></td></tr>
<tr class="separator:a723ae048998935420493a23ee5ea991e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27716e9a50252e78dfbd00882f043510"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a27716e9a50252e78dfbd00882f043510"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a27716e9a50252e78dfbd00882f043510">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a27716e9a50252e78dfbd00882f043510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space).  <a href="#a27716e9a50252e78dfbd00882f043510">More...</a><br /></td></tr>
<tr class="separator:a27716e9a50252e78dfbd00882f043510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731877def65722027447923a18bfe442"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a731877def65722027447923a18bfe442"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a731877def65722027447923a18bfe442">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a731877def65722027447923a18bfe442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space).  <a href="#a731877def65722027447923a18bfe442">More...</a><br /></td></tr>
<tr class="separator:a731877def65722027447923a18bfe442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0020b01053f44190ce800c02c652c4d"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad0020b01053f44190ce800c02c652c4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad0020b01053f44190ce800c02c652c4d">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad0020b01053f44190ce800c02c652c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used).  <a href="#ad0020b01053f44190ce800c02c652c4d">More...</a><br /></td></tr>
<tr class="separator:ad0020b01053f44190ce800c02c652c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aaa5d861f8a59da22b6c952478fe8a3ff">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied).  <a href="#aaa5d861f8a59da22b6c952478fe8a3ff">More...</a><br /></td></tr>
<tr class="separator:aaa5d861f8a59da22b6c952478fe8a3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a8f11e994cb65b886bfd653202a76"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ae48a8f11e994cb65b886bfd653202a76"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ae48a8f11e994cb65b886bfd653202a76">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ae48a8f11e994cb65b886bfd653202a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#ae48a8f11e994cb65b886bfd653202a76">More...</a><br /></td></tr>
<tr class="separator:ae48a8f11e994cb65b886bfd653202a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa185548adae9af94131880d62bbabc7e"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa185548adae9af94131880d62bbabc7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa185548adae9af94131880d62bbabc7e">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa185548adae9af94131880d62bbabc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#aa185548adae9af94131880d62bbabc7e">More...</a><br /></td></tr>
<tr class="separator:aa185548adae9af94131880d62bbabc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e606467a37be4814415340f0e730c"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad88e606467a37be4814415340f0e730c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad88e606467a37be4814415340f0e730c">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad88e606467a37be4814415340f0e730c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space).  <a href="#ad88e606467a37be4814415340f0e730c">More...</a><br /></td></tr>
<tr class="separator:ad88e606467a37be4814415340f0e730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f1b52002d4f069041329ad968ebc8"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa50f1b52002d4f069041329ad968ebc8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa50f1b52002d4f069041329ad968ebc8">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa50f1b52002d4f069041329ad968ebc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space).  <a href="#aa50f1b52002d4f069041329ad968ebc8">More...</a><br /></td></tr>
<tr class="separator:aa50f1b52002d4f069041329ad968ebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11326936be89261963fcc56f41c15462"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a11326936be89261963fcc56f41c15462"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a11326936be89261963fcc56f41c15462">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a11326936be89261963fcc56f41c15462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used).  <a href="#a11326936be89261963fcc56f41c15462">More...</a><br /></td></tr>
<tr class="separator:a11326936be89261963fcc56f41c15462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8ef7bbeba344f2badd87c6eb96677e3b">make_elliptic_ipdg_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied).  <a href="#a8ef7bbeba344f2badd87c6eb96677e3b">More...</a><br /></td></tr>
<tr class="separator:a8ef7bbeba344f2badd87c6eb96677e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1687b0deb307fedd89aa3ce0420443f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac1687b0deb307fedd89aa3ce0420443f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac1687b0deb307fedd89aa3ce0420443f">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac1687b0deb307fedd89aa3ce0420443f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#ac1687b0deb307fedd89aa3ce0420443f">More...</a><br /></td></tr>
<tr class="separator:ac1687b0deb307fedd89aa3ce0420443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a244d38839d3e1f19883cdd2b1dd07f3c">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#a244d38839d3e1f19883cdd2b1dd07f3c">More...</a><br /></td></tr>
<tr class="separator:a244d38839d3e1f19883cdd2b1dd07f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5d7d95d7700b45a8690ba2bc6a8bb020">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space).  <a href="#a5d7d95d7700b45a8690ba2bc6a8bb020">More...</a><br /></td></tr>
<tr class="separator:a5d7d95d7700b45a8690ba2bc6a8bb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1154218ae80f409ab597655b27e3ec"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a0e1154218ae80f409ab597655b27e3ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a0e1154218ae80f409ab597655b27e3ec">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a0e1154218ae80f409ab597655b27e3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space).  <a href="#a0e1154218ae80f409ab597655b27e3ec">More...</a><br /></td></tr>
<tr class="separator:a0e1154218ae80f409ab597655b27e3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe0640b34f33baafaadb61e440d80a2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a2fe0640b34f33baafaadb61e440d80a2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a2fe0640b34f33baafaadb61e440d80a2">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a2fe0640b34f33baafaadb61e440d80a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used).  <a href="#a2fe0640b34f33baafaadb61e440d80a2">More...</a><br /></td></tr>
<tr class="separator:a2fe0640b34f33baafaadb61e440d80a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac305bd91061a17898645ef78e47ad11f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ac305bd91061a17898645ef78e47ad11f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac305bd91061a17898645ef78e47ad11f">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac305bd91061a17898645ef78e47ad11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied).  <a href="#ac305bd91061a17898645ef78e47ad11f">More...</a><br /></td></tr>
<tr class="separator:ac305bd91061a17898645ef78e47ad11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5a19aae1548e2aaa5c4ad71b6a72466a">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used).  <a href="#a5a19aae1548e2aaa5c4ad71b6a72466a">More...</a><br /></td></tr>
<tr class="separator:a5a19aae1548e2aaa5c4ad71b6a72466a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa819bbf4e4799bf4501031a635645b40"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa819bbf4e4799bf4501031a635645b40"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa819bbf4e4799bf4501031a635645b40">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa819bbf4e4799bf4501031a635645b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used).  <a href="#aa819bbf4e4799bf4501031a635645b40">More...</a><br /></td></tr>
<tr class="separator:aa819bbf4e4799bf4501031a635645b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a4ccb6c2d56014a31dfa7f96fc6358919">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space).  <a href="#a4ccb6c2d56014a31dfa7f96fc6358919">More...</a><br /></td></tr>
<tr class="separator:a4ccb6c2d56014a31dfa7f96fc6358919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5008a3fbbd914460f557f656d83328"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f5008a3fbbd914460f557f656d83328"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1f5008a3fbbd914460f557f656d83328">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a1f5008a3fbbd914460f557f656d83328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space).  <a href="#a1f5008a3fbbd914460f557f656d83328">More...</a><br /></td></tr>
<tr class="separator:a1f5008a3fbbd914460f557f656d83328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a26a1a51d0e80b2681d20c0f1b5b8bd94">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (default IPDG method is used).  <a href="#a26a1a51d0e80b2681d20c0f1b5b8bd94">More...</a><br /></td></tr>
<tr class="separator:a26a1a51d0e80b2681d20c0f1b5b8bd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1f8f8f71e1f1d2e056507159a06a4dad">make_elliptic_ipdg_matrix_operator</a> (const DiffusionType &amp;diffusion, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix IPDG operator (IPDG method has to be supplied).  <a href="#a1f8f8f71e1f1d2e056507159a06a4dad">More...</a><br /></td></tr>
<tr class="separator:a1f8f8f71e1f1d2e056507159a06a4dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4bc8e7face047ca003488d5fa49222"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:abd4bc8e7face047ca003488d5fa49222"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; RangeType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01810.html">EllipticLocalizableProduct</a>&lt; DiffusionType, void, GridLayerType, RangeType, SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abd4bc8e7face047ca003488d5fa49222">make_elliptic_localizable_product</a> (const DiffusionType &amp;diffusion, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:abd4bc8e7face047ca003488d5fa49222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0540718ef11a506fc7460414061113"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a3e0540718ef11a506fc7460414061113"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; RangeType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01810.html">EllipticLocalizableProduct</a>&lt; DiffusionFactorType, DiffusionTensorType, GridLayerType, RangeType, SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3e0540718ef11a506fc7460414061113">make_elliptic_localizable_product</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a3e0540718ef11a506fc7460414061113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </td></tr>
<tr class="memitem:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8e5ac11789f5a6a20eb9c4c591f7590f">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a8e5ac11789f5a6a20eb9c4c591f7590f">More...</a><br /></td></tr>
<tr class="separator:a8e5ac11789f5a6a20eb9c4c591f7590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa2b417cfe37ddd413a1a88f8d4832b7d">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#aa2b417cfe37ddd413a1a88f8d4832b7d">More...</a><br /></td></tr>
<tr class="separator:aa2b417cfe37ddd413a1a88f8d4832b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e8de41cd99705c54a463ff8979abb4"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad4e8de41cd99705c54a463ff8979abb4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad4e8de41cd99705c54a463ff8979abb4">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad4e8de41cd99705c54a463ff8979abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#ad4e8de41cd99705c54a463ff8979abb4">More...</a><br /></td></tr>
<tr class="separator:ad4e8de41cd99705c54a463ff8979abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac79ebd71eca30efd87b6f57c0f49f600">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac79ebd71eca30efd87b6f57c0f49f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#ac79ebd71eca30efd87b6f57c0f49f600">More...</a><br /></td></tr>
<tr class="separator:ac79ebd71eca30efd87b6f57c0f49f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f78e3513c8c8445e9b7065419041030"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a6f78e3513c8c8445e9b7065419041030"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6f78e3513c8c8445e9b7065419041030">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a6f78e3513c8c8445e9b7065419041030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (source and range space are given by space).  <a href="#a6f78e3513c8c8445e9b7065419041030">More...</a><br /></td></tr>
<tr class="separator:a6f78e3513c8c8445e9b7065419041030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memTemplParams" colspan="2">template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad4f6e182a9cecb5d8c8f9bb6da507e36">make_elliptic_matrix_operator</a> (const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator.  <a href="#ad4f6e182a9cecb5d8c8f9bb6da507e36">More...</a><br /></td></tr>
<tr class="separator:ad4f6e182a9cecb5d8c8f9bb6da507e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645898ad9e18b9ee082694eb129be6e5"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a645898ad9e18b9ee082694eb129be6e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a645898ad9e18b9ee082694eb129be6e5">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a645898ad9e18b9ee082694eb129be6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a645898ad9e18b9ee082694eb129be6e5">More...</a><br /></td></tr>
<tr class="separator:a645898ad9e18b9ee082694eb129be6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a59f7a9e88dc8fb3ea1bc7b5847d148e2">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a59f7a9e88dc8fb3ea1bc7b5847d148e2">More...</a><br /></td></tr>
<tr class="separator:a59f7a9e88dc8fb3ea1bc7b5847d148e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b492fe167180d66b57155a9c4efc20"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab1b492fe167180d66b57155a9c4efc20"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab1b492fe167180d66b57155a9c4efc20">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ab1b492fe167180d66b57155a9c4efc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically).  <a href="#ab1b492fe167180d66b57155a9c4efc20">More...</a><br /></td></tr>
<tr class="separator:ab1b492fe167180d66b57155a9c4efc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b224a5d8038ccad232f22cd4f94392c"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a4b224a5d8038ccad232f22cd4f94392c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a4b224a5d8038ccad232f22cd4f94392c">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4b224a5d8038ccad232f22cd4f94392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, source and range space are given by space, grid_layer of the space is used).  <a href="#a4b224a5d8038ccad232f22cd4f94392c">More...</a><br /></td></tr>
<tr class="separator:a4b224a5d8038ccad232f22cd4f94392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad25dd39c95e458ac83ee12b6f50b105d">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ad25dd39c95e458ac83ee12b6f50b105d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given, source and range space are given by space).  <a href="#ad25dd39c95e458ac83ee12b6f50b105d">More...</a><br /></td></tr>
<tr class="separator:ad25dd39c95e458ac83ee12b6f50b105d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b601eea0442b605302ad79f18056d87"><td class="memTemplParams" colspan="2">template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4b601eea0442b605302ad79f18056d87"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt; DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a4b601eea0442b605302ad79f18056d87">make_elliptic_matrix_operator</a> (const DiffusionType &amp;diffusion, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4b601eea0442b605302ad79f18056d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an elliptic matrix operator (single diffusion given).  <a href="#a4b601eea0442b605302ad79f18056d87">More...</a><br /></td></tr>
<tr class="separator:a4b601eea0442b605302ad79f18056d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d25b2d08b99737792191ea9dc56b529"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class DiffusionType &gt; </td></tr>
<tr class="memitem:a6d25b2d08b99737792191ea9dc56b529"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01818.html">EllipticOperator</a>&lt; DiffusionType, void, GridLayerType, typename DiffusionType::RangeFieldType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6d25b2d08b99737792191ea9dc56b529">make_elliptic_operator</a> (const GridLayerType &amp;grid_layer, const DiffusionType &amp;diffusion, const size_t over_integrate=0)</td></tr>
<tr class="separator:a6d25b2d08b99737792191ea9dc56b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class DiffusionFactorType , class DiffusionTensorType &gt; </td></tr>
<tr class="memitem:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionFactorType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; DiffusionTensorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a01818.html">EllipticOperator</a>&lt; DiffusionFactorType, DiffusionTensorType, GridLayerType, typename DiffusionFactorType::RangeFieldType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1757fab0086f1e2e9767645fc23fd9c5">make_elliptic_operator</a> (const GridLayerType &amp;grid_layer, const DiffusionFactorType &amp;diffusion_factor, const DiffusionTensorType &amp;diffusion_tensor, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1757fab0086f1e2e9767645fc23fd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memTemplParams" colspan="2">template&lt;LocalEllipticIpdgIntegrands::Method m, class GL , class DF , class DT &gt; </td></tr>
<tr class="memitem:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01830.html">DiffusiveFluxReconstructionOperator</a>&lt; GL, DF, DT, m &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a0ef1828dbb87ea7925b06e2fb3592981">make_diffusive_flux_reconstruction_operator</a> (const GL &amp;grid_layer, const DF &amp;diffusion_factor, const DT &amp;diffusion_tensor, const size_t over_integrate=0)</td></tr>
<tr class="separator:a0ef1828dbb87ea7925b06e2fb3592981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3a68504ab32dceaf20a367e2617b58"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a1a3a68504ab32dceaf20a367e2617b58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; RangeType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02022.html">L2LocalizableProduct</a>&lt; GridLayerType, RangeType, SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1a3a68504ab32dceaf20a367e2617b58">make_l2_localizable_product</a> (const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a1a3a68504ab32dceaf20a367e2617b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa6df3ece6d2703ff6bedf3420c5e3a95">make_l2_matrix_operator</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#aa6df3ece6d2703ff6bedf3420c5e3a95">More...</a><br /></td></tr>
<tr class="separator:aa6df3ece6d2703ff6bedf3420c5e3a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a19320cc6468677248b8ab4eed3b3de"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a4a19320cc6468677248b8ab4eed3b3de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a4a19320cc6468677248b8ab4eed3b3de">make_l2_matrix_operator</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a4a19320cc6468677248b8ab4eed3b3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a4a19320cc6468677248b8ab4eed3b3de">More...</a><br /></td></tr>
<tr class="separator:a4a19320cc6468677248b8ab4eed3b3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a59bd3e4a730d2e05605abbee7bcd9baf">make_l2_matrix_operator</a> (const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a59bd3e4a730d2e05605abbee7bcd9baf">More...</a><br /></td></tr>
<tr class="separator:a59bd3e4a730d2e05605abbee7bcd9baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca65e541579ace42958d0248e85dc8e"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:aaca65e541579ace42958d0248e85dc8e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aaca65e541579ace42958d0248e85dc8e">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aaca65e541579ace42958d0248e85dc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#aaca65e541579ace42958d0248e85dc8e">More...</a><br /></td></tr>
<tr class="separator:aaca65e541579ace42958d0248e85dc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3aa7d90d3f800e69ceb9956818a7ab29">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator (source and range space are given by space).  <a href="#a3aa7d90d3f800e69ceb9956818a7ab29">More...</a><br /></td></tr>
<tr class="separator:a3aa7d90d3f800e69ceb9956818a7ab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8805736f27ea9f91b346e93251ffcaf"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa8805736f27ea9f91b346e93251ffcaf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02030.html">L2MatrixOperator</a>&lt; RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa8805736f27ea9f91b346e93251ffcaf">make_l2_matrix_operator</a> (MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa8805736f27ea9f91b346e93251ffcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an L2 matrix operator.  <a href="#aa8805736f27ea9f91b346e93251ffcaf">More...</a><br /></td></tr>
<tr class="separator:aa8805736f27ea9f91b346e93251ffcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02038.html">L2Operator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aaa8d9d3c704dad52fe1215c40ce7755e">make_l2_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:aaa8d9d3c704dad52fe1215c40ce7755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7129f2ce7fb2ad7bb8403d0e2378e1d1"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:a7129f2ce7fb2ad7bb8403d0e2378e1d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; RangeType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02046.html">LaplaceLocalizableProduct</a>&lt; GridLayerType, RangeType, SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a7129f2ce7fb2ad7bb8403d0e2378e1d1">make_laplace_localizable_product</a> (const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a7129f2ce7fb2ad7bb8403d0e2378e1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58267637036be6ee37f0e48d1162ab0"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:ac58267637036be6ee37f0e48d1162ab0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac58267637036be6ee37f0e48d1162ab0">make_laplace_matrix_operator</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ac58267637036be6ee37f0e48d1162ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#ac58267637036be6ee37f0e48d1162ab0">More...</a><br /></td></tr>
<tr class="separator:ac58267637036be6ee37f0e48d1162ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e793f951853fe2462720fbdb0efe2"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:ab45e793f951853fe2462720fbdb0efe2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab45e793f951853fe2462720fbdb0efe2">make_laplace_matrix_operator</a> (const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:ab45e793f951853fe2462720fbdb0efe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#ab45e793f951853fe2462720fbdb0efe2">More...</a><br /></td></tr>
<tr class="separator:ab45e793f951853fe2462720fbdb0efe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c2435913bbaefd577916a044eeaff"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a187c2435913bbaefd577916a044eeaff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a187c2435913bbaefd577916a044eeaff">make_laplace_matrix_operator</a> (const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a187c2435913bbaefd577916a044eeaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a187c2435913bbaefd577916a044eeaff">More...</a><br /></td></tr>
<tr class="separator:a187c2435913bbaefd577916a044eeaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a73a1412fbe2dd31bb9c7c48f943fecb8">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#a73a1412fbe2dd31bb9c7c48f943fecb8">More...</a><br /></td></tr>
<tr class="separator:a73a1412fbe2dd31bb9c7c48f943fecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f40f54739e0f5758158c62af274630"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:aa2f40f54739e0f5758158c62af274630"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa2f40f54739e0f5758158c62af274630">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:aa2f40f54739e0f5758158c62af274630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator (source and range space are given by space).  <a href="#aa2f40f54739e0f5758158c62af274630">More...</a><br /></td></tr>
<tr class="separator:aa2f40f54739e0f5758158c62af274630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfd627da92f1aa70984f784203f0f57"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a5bfd627da92f1aa70984f784203f0f57"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt; RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5bfd627da92f1aa70984f784203f0f57">make_laplace_matrix_operator</a> (MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a5bfd627da92f1aa70984f784203f0f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplace matrix operator.  <a href="#a5bfd627da92f1aa70984f784203f0f57">More...</a><br /></td></tr>
<tr class="separator:a5bfd627da92f1aa70984f784203f0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c77184eaff56d640da03fc408d27b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a614c77184eaff56d640da03fc408d27b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02062.html">LaplaceOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a614c77184eaff56d640da03fc408d27b">make_laplace_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a614c77184eaff56d640da03fc408d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb42db46ca6c5872fde464ac03a2b2"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class GridLayerType , class RangeType , class SourceType &gt; </td></tr>
<tr class="memitem:ab8eb42db46ca6c5872fde464ac03a2b2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; RangeType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02078.html">WeightedL2LocalizableProduct</a>&lt; WeightFunctionType, GridLayerType, RangeType, SourceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab8eb42db46ca6c5872fde464ac03a2b2">make_weighted_l2_localizable_product</a> (const WeightFunctionType &amp;weight, const GridLayerType &amp;grid_layer, const RangeType &amp;range, const SourceType &amp;source, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:ab8eb42db46ca6c5872fde464ac03a2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c370bc5da752091bf363382ccad66f"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class SpaceType &gt; </td></tr>
<tr class="memitem:a94c370bc5da752091bf363382ccad66f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a94c370bc5da752091bf363382ccad66f">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a94c370bc5da752091bf363382ccad66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used).  <a href="#a94c370bc5da752091bf363382ccad66f">More...</a><br /></td></tr>
<tr class="separator:a94c370bc5da752091bf363382ccad66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d49e35616d30a21a82601a8358d85"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a419d49e35616d30a21a82601a8358d85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a419d49e35616d30a21a82601a8358d85">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a419d49e35616d30a21a82601a8358d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space).  <a href="#a419d49e35616d30a21a82601a8358d85">More...</a><br /></td></tr>
<tr class="separator:a419d49e35616d30a21a82601a8358d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790f22db7ca14a73ae19e9993742320"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , class WeightFunctionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a8790f22db7ca14a73ae19e9993742320"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8790f22db7ca14a73ae19e9993742320">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a8790f22db7ca14a73ae19e9993742320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically).  <a href="#a8790f22db7ca14a73ae19e9993742320">More...</a><br /></td></tr>
<tr class="separator:a8790f22db7ca14a73ae19e9993742320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c65510f0494c44231137be7b61eb712"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class SpaceType &gt; </td></tr>
<tr class="memitem:a6c65510f0494c44231137be7b61eb712"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6c65510f0494c44231137be7b61eb712">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a6c65510f0494c44231137be7b61eb712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (source and range space are given by space, grid_layer of the space is used).  <a href="#a6c65510f0494c44231137be7b61eb712">More...</a><br /></td></tr>
<tr class="separator:a6c65510f0494c44231137be7b61eb712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class SpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a7fa80f01415bd014fdc5dd79dd286edc">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:a7fa80f01415bd014fdc5dd79dd286edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator (source and range space are given by space).  <a href="#a7fa80f01415bd014fdc5dd79dd286edc">More...</a><br /></td></tr>
<tr class="separator:a7fa80f01415bd014fdc5dd79dd286edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ae6d54b1de546de981980dcc26c961"><td class="memTemplParams" colspan="2">template&lt;class WeightFunctionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </td></tr>
<tr class="memitem:af9ae6d54b1de546de981980dcc26c961"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;XT::LA::is_matrix&lt; MatrixType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt; WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#af9ae6d54b1de546de981980dcc26c961">make_weighted_l2_matrix_operator</a> (const WeightFunctionType &amp;weight, MatrixType &amp;matrix, const RangeSpaceType &amp;range_space, const SourceSpaceType &amp;source_space, const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="memdesc:af9ae6d54b1de546de981980dcc26c961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a weighted L2 matrix operator.  <a href="#af9ae6d54b1de546de981980dcc26c961">More...</a><br /></td></tr>
<tr class="separator:af9ae6d54b1de546de981980dcc26c961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f2e7c92b7268e11b82ccea2407271"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class WeightFunctionType &gt; </td></tr>
<tr class="memitem:ac54f2e7c92b7268e11b82ccea2407271"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; WeightFunctionType &gt;::value &amp;&amp;XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02086.html">WeightedL2Operator</a>&lt; WeightFunctionType, GridLayerType, typename WeightFunctionType::RangeFieldType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ac54f2e7c92b7268e11b82ccea2407271">make_weighted_l2_operator</a> (const GridLayerType &amp;grid_layer, const WeightFunctionType &amp;weight, const size_t over_integrate=0)</td></tr>
<tr class="separator:ac54f2e7c92b7268e11b82ccea2407271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class RangeType &gt; </td></tr>
<tr class="memitem:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a02166.html">DirichletProjectionLocalizableOperator</a>&lt; GridLayerType, SourceType, RangeType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8f639f3b2734291a3ab3c17c8894fdcb">make_localizable_dirichlet_projection_operator</a> (const GridLayerType &amp;grid_layer, const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;boundary_info, const SourceType &amp;source, RangeType &amp;range)</td></tr>
<tr class="separator:a8f639f3b2734291a3ab3c17c8894fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02178.html">L2GlobalProjectionLocalizableOperator</a>&lt; GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab6adbf86b5d86a023e2e8e93cbcbc6d5">make_global_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ab6adbf86b5d86a023e2e8e93cbcbc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5f8915864e0699caf07017b3f0bbd9"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ada5f8915864e0699caf07017b3f0bbd9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02178.html">L2GlobalProjectionLocalizableOperator</a>&lt; typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ada5f8915864e0699caf07017b3f0bbd9">make_global_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ada5f8915864e0699caf07017b3f0bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02170.html">L2GlobalProjectionOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a1dc211dfec7d3c46b5d59c7b1403bdf5">make_global_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a1dc211dfec7d3c46b5d59c7b1403bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1612b90648aab6894d91e094dbba596"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab1612b90648aab6894d91e094dbba596"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02198.html">L2LocalProjectionLocalizableOperator</a>&lt; GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab1612b90648aab6894d91e094dbba596">make_local_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:ab1612b90648aab6894d91e094dbba596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5983630b75ef508253bcbf202327c73"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ad5983630b75ef508253bcbf202327c73"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02198.html">L2LocalProjectionLocalizableOperator</a>&lt; typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ad5983630b75ef508253bcbf202327c73">make_local_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:ad5983630b75ef508253bcbf202327c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72af8b84996d16c4b31bbceaceefca6f"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a72af8b84996d16c4b31bbceaceefca6f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02190.html">L2LocalProjectionOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a72af8b84996d16c4b31bbceaceefca6f">make_local_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a72af8b84996d16c4b31bbceaceefca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb37c26aebc4f0de53587319f55a017b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:abb37c26aebc4f0de53587319f55a017b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02230.html">L2ProjectionLocalizableOperator</a>&lt; GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abb37c26aebc4f0de53587319f55a017b">make_l2_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:abb37c26aebc4f0de53587319f55a017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fda08c8477972bb5135da2513518dc"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:aa1fda08c8477972bb5135da2513518dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02230.html">L2ProjectionLocalizableOperator</a>&lt; typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa1fda08c8477972bb5135da2513518dc">make_l2_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:aa1fda08c8477972bb5135da2513518dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02210.html">L2ProjectionOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a53207d499f1a26958db4d5efb6ba6bdb">make_l2_projection_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a53207d499f1a26958db4d5efb6ba6bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739fd9a05d811357d4e054e61017b4be"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a739fd9a05d811357d4e054e61017b4be"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a739fd9a05d811357d4e054e61017b4be">project_l2</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a739fd9a05d811357d4e054e61017b4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce48b8d05bd6a7e3c9f4fb215eb0b93"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a3ce48b8d05bd6a7e3c9f4fb215eb0b93"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3ce48b8d05bd6a7e3c9f4fb215eb0b93">project_l2</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a3ce48b8d05bd6a7e3c9f4fb215eb0b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5160a18176f922670606c9fabaaeed"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a5d5160a18176f922670606c9fabaaeed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02242.html">LagrangeProjectionLocalizableOperator</a>&lt; GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5d5160a18176f922670606c9fabaaeed">make_lagrange_projection_localizable_operator</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a5d5160a18176f922670606c9fabaaeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80017c8590156bbc14e3b5809d9b5706"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a80017c8590156bbc14e3b5809d9b5706"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02242.html">LagrangeProjectionLocalizableOperator</a>&lt; typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a80017c8590156bbc14e3b5809d9b5706">make_lagrange_projection_localizable_operator</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a80017c8590156bbc14e3b5809d9b5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd9942fa032bb572db38180e9602c4e"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a6bd9942fa032bb572db38180e9602c4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02246.html">LagrangeProjectionOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a6bd9942fa032bb572db38180e9602c4e">make_lagrange_projection_operator</a> (const GridLayerType &amp;grid_layer)</td></tr>
<tr class="separator:a6bd9942fa032bb572db38180e9602c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d76b5da36129c1d49c8e677e830218"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:a48d76b5da36129c1d49c8e677e830218"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a48d76b5da36129c1d49c8e677e830218">project_lagrange</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a48d76b5da36129c1d49c8e677e830218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda2ed2cfc25f129a952054c203923a3"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:abda2ed2cfc25f129a952054c203923a3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#abda2ed2cfc25f129a952054c203923a3">project_lagrange</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:abda2ed2cfc25f129a952054c203923a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03030.html">is_cg_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab28f3c4b54b4fb8206d8b24f2f2c1e32">project</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:ab28f3c4b54b4fb8206d8b24f2f2c1e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;!<a class="el" href="a03030.html">is_cg_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab6930f61566d99bf1e2ad1a1ea8ebdda">project</a> (const GridLayerType &amp;grid_layer, const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:ab6930f61566d99bf1e2ad1a1ea8ebdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2246f50ebf840a99127b39c957faadf"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:ab2246f50ebf840a99127b39c957faadf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;<a class="el" href="a03030.html">is_cg_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab2246f50ebf840a99127b39c957faadf">project</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:ab2246f50ebf840a99127b39c957faadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memTemplParams" colspan="2">template&lt;class SourceType , class SpaceType , class VectorType &gt; </td></tr>
<tr class="memitem:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Functions::is_localizable_function&lt; SourceType &gt;::value &amp;&amp;!<a class="el" href="a03030.html">is_cg_space</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &gt;::value &amp;&amp;XT::LA::is_vector&lt; VectorType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#add15cc27cd3d12bd7a1e30e5bf37224f">project</a> (const SourceType &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:add15cc27cd3d12bd7a1e30e5bf37224f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9ec66c9a827b012b33a1d458d58292"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aeb9ec66c9a827b012b33a1d458d58292"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; SourceVectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; RangeVectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02262.html">L2GlobalProlongationLocalizableOperator</a>&lt; GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aeb9ec66c9a827b012b33a1d458d58292">make_global_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:aeb9ec66c9a827b012b33a1d458d58292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9772649b7272d7feee16e3cc0057d4a2"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a9772649b7272d7feee16e3cc0057d4a2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; SourceVectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; RangeVectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02262.html">L2GlobalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a9772649b7272d7feee16e3cc0057d4a2">make_global_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a9772649b7272d7feee16e3cc0057d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a3610e71d59f474af2dfd988fc868"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a564a3610e71d59f474af2dfd988fc868"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02254.html">L2GlobalProlongationOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a564a3610e71d59f474af2dfd988fc868">make_global_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a564a3610e71d59f474af2dfd988fc868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a54eebb2c635b8f582ad3e43941b14"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:af5a54eebb2c635b8f582ad3e43941b14"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; SourceVectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; RangeVectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02274.html">L2LocalProlongationLocalizableOperator</a>&lt; GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#af5a54eebb2c635b8f582ad3e43941b14">make_local_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:af5a54eebb2c635b8f582ad3e43941b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b90a04cecdb9a4caa0dc6d876c0b0d1"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a9b90a04cecdb9a4caa0dc6d876c0b0d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a03006.html">is_space</a>&lt; SourceSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; SourceVectorType &gt;::value &amp;&amp;<a class="el" href="a03006.html">is_space</a>&lt; RangeSpaceType &gt;::value &amp;&amp;XT::LA::is_vector&lt; RangeVectorType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02274.html">L2LocalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a9b90a04cecdb9a4caa0dc6d876c0b0d1">make_local_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a9b90a04cecdb9a4caa0dc6d876c0b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02266.html">L2LocalProlongationOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ae259c74e23bd82ed2bdb7bc190df8093">make_local_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:ae259c74e23bd82ed2bdb7bc190df8093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa746df909339503f60a17661285bc4"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a3fa746df909339503f60a17661285bc4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02298.html">L2ProlongationLocalizableOperator</a>&lt; GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a3fa746df909339503f60a17661285bc4">make_l2_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a3fa746df909339503f60a17661285bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0091fab2708f1a388b30a247166ae55c"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a0091fab2708f1a388b30a247166ae55c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a02298.html">L2ProlongationLocalizableOperator</a>&lt; typename RS::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a0091fab2708f1a388b30a247166ae55c">make_l2_prolongation_localizable_operator</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a0091fab2708f1a388b30a247166ae55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f74bd1b2248a25d0c380d3464f4724"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:a66f74bd1b2248a25d0c380d3464f4724"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02278.html">L2ProlongationOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a66f74bd1b2248a25d0c380d3464f4724">make_l2_prolongation_operator</a> (const GridLayerType &amp;grid_layer, const size_t over_integrate=0)</td></tr>
<tr class="separator:a66f74bd1b2248a25d0c380d3464f4724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fab99cb387849e714c05a0d2b27c197"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a8fab99cb387849e714c05a0d2b27c197"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8fab99cb387849e714c05a0d2b27c197">prolong_l2</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a8fab99cb387849e714c05a0d2b27c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a961b32a7982c5bf781045fbfa0eb9aab">prolong_l2</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a961b32a7982c5bf781045fbfa0eb9aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff7e797cda0076652379f9a8c2b5c16"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a8ff7e797cda0076652379f9a8c2b5c16"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02318.html">LagrangeProlongationLocalizableOperator</a>&lt; GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a8ff7e797cda0076652379f9a8c2b5c16">make_lagrange_prolongation_localizable_operator</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a8ff7e797cda0076652379f9a8c2b5c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa322e33210fa15e3b02471f4f9250b5e"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aa322e33210fa15e3b02471f4f9250b5e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a02318.html">LagrangeProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa322e33210fa15e3b02471f4f9250b5e">make_lagrange_prolongation_localizable_operator</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:aa322e33210fa15e3b02471f4f9250b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a31d2d051596296e00ceea186232b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType &gt; </td></tr>
<tr class="memitem:ab39a31d2d051596296e00ceea186232b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, std::unique_ptr&lt; <a class="el" href="a02310.html">LagrangeProlongationOperator</a>&lt; GridLayerType &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#ab39a31d2d051596296e00ceea186232b">make_lagrange_prolongation_operator</a> (const GridLayerType &amp;grid_layer)</td></tr>
<tr class="separator:ab39a31d2d051596296e00ceea186232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83a245e10e4fe1a2ae4006d0527c89"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a9a83a245e10e4fe1a2ae4006d0527c89"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a9a83a245e10e4fe1a2ae4006d0527c89">prolong_lagrange</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a9a83a245e10e4fe1a2ae4006d0527c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9b021f5197437b7c25d50a86c0a72"><td class="memTemplParams" colspan="2">template&lt;class SS , class SV , class RS , class RV &gt; </td></tr>
<tr class="memitem:a07b9b021f5197437b7c25d50a86c0a72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a07b9b021f5197437b7c25d50a86c0a72">prolong_lagrange</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;range, const XT::Common::Parameter &amp;param={})</td></tr>
<tr class="separator:a07b9b021f5197437b7c25d50a86c0a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08c25274fd4dd387590da5f9087f4ea"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aa08c25274fd4dd387590da5f9087f4ea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;<a class="el" href="a03030.html">is_cg_space</a>&lt; RangeSpaceType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa08c25274fd4dd387590da5f9087f4ea">prolong</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:aa08c25274fd4dd387590da5f9087f4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af392b611b527d3309b23f902cae6bf4b"><td class="memTemplParams" colspan="2">template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:af392b611b527d3309b23f902cae6bf4b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; XT::Grid::is_layer&lt; GridLayerType &gt;::value &amp;&amp;!<a class="el" href="a03030.html">is_cg_space</a>&lt; RangeSpaceType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#af392b611b527d3309b23f902cae6bf4b">prolong</a> (const GridLayerType &amp;grid_layer, const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:af392b611b527d3309b23f902cae6bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="a03030.html">is_cg_space</a>&lt; RangeSpaceType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5b3045aa4dc67c8c6aa40604468a8ec7">prolong</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t=0)</td></tr>
<tr class="separator:a5b3045aa4dc67c8c6aa40604468a8ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857b2b6325e4bf58234495716f241819"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:a857b2b6325e4bf58234495716f241819"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="a03030.html">is_cg_space</a>&lt; RangeSpaceType &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a857b2b6325e4bf58234495716f241819">prolong</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:a857b2b6325e4bf58234495716f241819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa033d6900fdcffdafedd4d950267819e"><td class="memTemplParams" colspan="2">template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </td></tr>
<tr class="memitem:aa033d6900fdcffdafedd4d950267819e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aa033d6900fdcffdafedd4d950267819e">prolong</a> (const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;source, <a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a02102.html">BlockSpace</a>&lt; RangeSpaceType &gt;, RangeVectorType &gt; &amp;range, const size_t over_integrate=0)</td></tr>
<tr class="separator:aa033d6900fdcffdafedd4d950267819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memTemplParams" colspan="2">template&lt;class R , size_t r, size_t rC, class GL &gt; </td></tr>
<tr class="memitem:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02534.html">FvSpace</a>&lt; GL, R, r, rC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a5bd5ee218bea07115ecafce8f0d24a65">make_fv_space</a> (const GL &amp;grid_layer)</td></tr>
<tr class="separator:a5bd5ee218bea07115ecafce8f0d24a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memTemplParams" colspan="2">template&lt;class R , size_t r, class GL &gt; </td></tr>
<tr class="memitem:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02534.html">FvSpace</a>&lt; GL, R, r, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#afefce99b2e71a9fe2b8ba379beeb268d">make_fv_space</a> (const GL &amp;grid_layer)</td></tr>
<tr class="separator:afefce99b2e71a9fe2b8ba379beeb268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf97681edcb4a4c94f2c542ca834983e"><td class="memTemplParams" colspan="2">template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </td></tr>
<tr class="memitem:aaf97681edcb4a4c94f2c542ca834983e"><td class="memTemplItemLeft" align="right" valign="top">Traits::GridLayerType::template Codim&lt; codim &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#aaf97681edcb4a4c94f2c542ca834983e">begin</a> (const <a class="el" href="a02618.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;space)</td></tr>
<tr class="separator:aaf97681edcb4a4c94f2c542ca834983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ad5da890a94341a2a4c8ba68416a26"><td class="memTemplParams" colspan="2">template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </td></tr>
<tr class="memitem:a85ad5da890a94341a2a4c8ba68416a26"><td class="memTemplItemLeft" align="right" valign="top">Traits::GridLayerType::template Codim&lt; codim &gt;::Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a85ad5da890a94341a2a4c8ba68416a26">end</a> (const <a class="el" href="a02618.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;space)</td></tr>
<tr class="separator:a85ad5da890a94341a2a4c8ba68416a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a81e5609284c505b10ffff369ba619308"><td class="memTemplParams" colspan="2">template&lt;class MatrixType , size_t size&gt; </td></tr>
<tr class="memitem:a81e5609284c505b10ffff369ba619308"><td class="memTemplItemLeft" align="right" valign="top">static const std::unique_ptr&lt; const MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00231.html#a81e5609284c505b10ffff369ba619308">unit_matrix</a> = std::make_unique&lt;MatrixType&gt;(XT::LA::eye_matrix&lt;MatrixType&gt;(size, size))</td></tr>
<tr class="separator:a81e5609284c505b10ffff369ba619308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb8b6a35c3b20bf579f814239315ae"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a37fb8b6a35c3b20bf579f814239315ae">default_cg_backend</a> = <a class="el" href="a00231.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td></tr>
<tr class="separator:a37fb8b6a35c3b20bf579f814239315ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f51ae51b9d4e6763745a95fe0e52d8"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a30f51ae51b9d4e6763745a95fe0e52d8">default_dg_backend</a> = <a class="el" href="a00231.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td></tr>
<tr class="separator:a30f51ae51b9d4e6763745a95fe0e52d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cc306d857c4fc4efcd11b712f67eb2"><td class="memItemLeft" align="right" valign="top">static const XT::Common::FixedMap&lt; <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>, std::string, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#ac2cc306d857c4fc4efcd11b712f67eb2">backend_names</a> = {{<a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a>, &quot;gdt&quot;}}</td></tr>
<tr class="separator:ac2cc306d857c4fc4efcd11b712f67eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486607c0fc12b5da5bc46c20300b6dae"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a> = <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a></td></tr>
<tr class="separator:a486607c0fc12b5da5bc46c20300b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afd9e79bf2e05d76e877c835fa352f045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e79bf2e05d76e877c835fa352f045">&#9670;&nbsp;</a></span>Backends</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Dune::GDT::Backends</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b"></a>gdt&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a09f2467105da4217b0ff3bb2e4790c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f2467105da4217b0ff3bb2e4790c7e">&#9670;&nbsp;</a></span>ChoosePattern</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a09f2467105da4217b0ff3bb2e4790c7e">Dune::GDT::ChoosePattern</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a09f2467105da4217b0ff3bb2e4790c7ea210ab9e731c9c36c2c38db15c28a8d1c"></a>volume&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a09f2467105da4217b0ff3bb2e4790c7ead5ca322453f2986b752e58b11af83d96"></a>face&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a09f2467105da4217b0ff3bb2e4790c7eab68d75779ad98669ad5d654fe30a5827"></a>face_and_volume&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7d8c92722e087cefba1ac46ec1fa76f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8c92722e087cefba1ac46ec1fa76f0">&#9670;&nbsp;</a></span>NumericalFluxes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a7d8c92722e087cefba1ac46ec1fa76f0">Dune::GDT::NumericalFluxes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0aae254d63f2381cc183c11594873793e0"></a>force&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0a9399d693b7ac38875e19f1c38c4e4439"></a>godunov&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0a0f43c03a9e7ebc152cbaae416314ad69"></a>kinetic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0a088da8a28ff265eb3b7e18ae1fc24274"></a>laxfriedrichs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0a03070545f77a8199923fb2e80550deb2"></a>laxwendroff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0aa5aea357904deb91ca3777416848e6b0"></a>local_laxfriedrichs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7d8c92722e087cefba1ac46ec1fa76f0a230d6f2fbb1b2f868241b805b6f837e7"></a>musta&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5a9b3478d77a16697bf06fa3f949e0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9b3478d77a16697bf06fa3f949e0fa">&#9670;&nbsp;</a></span>RosenbrockTimeStepperMethods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a5a9b3478d77a16697bf06fa3f949e0fa">Dune::GDT::RosenbrockTimeStepperMethods</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a9b3478d77a16697bf06fa3f949e0faaefc42475d5c88b4e9d7e08dfeda6ef8b"></a>GRK4A&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a9b3478d77a16697bf06fa3f949e0faa9ed047981c608fb1716e2edee87aa5fc"></a>GRK4T&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5a9b3478d77a16697bf06fa3f949e0faa795f3202b17cb6bc3d4b771d8c6c9eaf"></a>other&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af68dfb986d335b9416add6ef64dfad58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68dfb986d335b9416add6ef64dfad58">&#9670;&nbsp;</a></span>SlopeLimiters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#af68dfb986d335b9416add6ef64dfad58">Dune::GDT::SlopeLimiters</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af68dfb986d335b9416add6ef64dfad58adbc1048da08be92092fbaf26e4561b4d"></a>minmod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af68dfb986d335b9416add6ef64dfad58ad6fd0924e324f50669ae0295adf59567"></a>mc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af68dfb986d335b9416add6ef64dfad58adbd796f5b863bc36af8381e5e641ce0e"></a>superbee&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af68dfb986d335b9416add6ef64dfad58a358f8b55910c75c446a7f3418fa87362"></a>no_slope&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1dc558b2ff4b8e95434d41c4e51f6b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc558b2ff4b8e95434d41c4e51f6b92">&#9670;&nbsp;</a></span>SpaceType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">Dune::GDT::SpaceType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a6e9cf3eef65da697796cf33f27eb0f57"></a>cg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92ab671d14735bdfcc6cf3ed3d691f5ebf4"></a>block_cg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a2f7e54fe9de9db73067f562bc22d6eae"></a>dg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a84fcd17e01407bf423248970c680b91c"></a>block_dg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a3c77f4029be2e609c22bba665f13b101"></a>fv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a8423b29b9be45caa628e4d0ade957cb1"></a>product_fv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92aad8ab1291b6657e98fc69a27f5504619"></a>block_fv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a822050d9ae3c47f54bee71b85fce1487"></a>rt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1dc558b2ff4b8e95434d41c4e51f6b92a4d8e6751d2f29f14859df8194924ef6c"></a>block_rt&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0a7e45c07c804e026c31fb0b86b7eb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7e45c07c804e026c31fb0b86b7eb69">&#9670;&nbsp;</a></span>TimeStepperMethods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#a0a7e45c07c804e026c31fb0b86b7eb69">Dune::GDT::TimeStepperMethods</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a6715245f54e8e2e94ddb3a731ccbdf10"></a>bogacki_shampine&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a696a706c4054d122f1275e54d1bc69c0"></a>dormand_prince&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ac97e4d5c331a2936e04feb034fc4f787"></a>adaptive_rungekutta_other&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ad8334dcb1e9c0f73386322960f66ace4"></a>explicit_euler&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a4bc67bde753aa72be3f0cab932ff12a8"></a>explicit_rungekutta_second_order_ssp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a0e84aa0f9a2d7d6b364450c7a66cd9a0"></a>explicit_rungekutta_third_order_ssp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ab3986d1a2cb34285ab615a07d9b2e8e1"></a>explicit_rungekutta_classic_fourth_order&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a3c2eeed127c2d2355fef6aaeaeac5012"></a>explicit_rungekutta_other&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ae9e3a7543796e9e0256a12f6dd5d4ecd"></a>implicit_euler&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ab84a8ef36b79ee75983435cd9b3de48c"></a>implicit_midpoint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a73c714ae3da44202127a7306c3efdebe"></a>trapezoidal_rule&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69a96b211390682c9d151b6579c4611ebc0"></a>diagonally_implicit_other&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0a7e45c07c804e026c31fb0b86b7eb69ae027c8edf587abe07bb3a0a3bfa154b6"></a>matrix_exponential&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad7583ef0313f2a3c3aa79768aa757b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7583ef0313f2a3c3aa79768aa757b28">&#9670;&nbsp;</a></span>TimeStepperSplittingMethods</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00231.html#ad7583ef0313f2a3c3aa79768aa757b28">Dune::GDT::TimeStepperSplittingMethods</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7583ef0313f2a3c3aa79768aa757b28a0ba4dc47ff49a8e6fb4d5ca1d6ae8518"></a>fractional_step&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7583ef0313f2a3c3aa79768aa757b28a09393b89e071daa6711ae0a264f34398"></a>strang&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf97681edcb4a4c94f2c542ca834983e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf97681edcb4a4c94f2c542ca834983e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::GridLayerType::template Codim&lt;codim&gt;::Iterator Dune::GDT::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02618.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85ad5da890a94341a2a4c8ba68416a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ad5da890a94341a2a4c8ba68416a26">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , size_t d, size_t r, size_t rC, size_t codim = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::GridLayerType::template Codim&lt;codim&gt;::Iterator Dune::GDT::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02618.html">Dune::GDT::SpaceInterface</a>&lt; Traits, d, r, rC &gt; &amp;&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b9c4a6f7b668a0b5d89f4f02d9f2257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9c4a6f7b668a0b5d89f4f02d9f2257">&#9670;&nbsp;</a></span>make_const_discrete_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; Dune::GDT::make_const_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.constdiscretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abebd2ad3553f76c53794b395f15d276e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebd2ad3553f76c53794b395f15d276e">&#9670;&nbsp;</a></span>make_darcy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a01786.html">DarcyOperator</a>&lt;G, F&gt; &gt; Dune::GDT::make_darcy </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ef1828dbb87ea7925b06e2fb3592981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef1828dbb87ea7925b06e2fb3592981">&#9670;&nbsp;</a></span>make_diffusive_flux_reconstruction_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method m, class GL , class DF , class DT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01830.html">DiffusiveFluxReconstructionOperator</a>&lt;GL, DF, DT, m&gt; Dune::GDT::make_diffusive_flux_reconstruction_operator </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DF &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DT &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6598655545d02249af38a6508ea0681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6598655545d02249af38a6508ea0681b">&#9670;&nbsp;</a></span>make_discrete_function() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt;::type Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d3e19a85ebe5c1fbbc4b77437af843c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3e19a85ebe5c1fbbc4b77437af843c">&#9670;&nbsp;</a></span>make_discrete_function() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt;::type Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a824112d0ae2d504cb60bf725b0b52811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824112d0ae2d504cb60bf725b0b52811">&#9670;&nbsp;</a></span>make_discrete_function() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; Dune::GDT::make_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>nm</em> = <code>&quot;gdt.discretefunction&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used like</p><div class="fragment"><div class="line"><span class="keyword">auto</span> discrete_function = make_discrete_function&lt;VectorType&gt;(space);</div></div><!-- fragment --> 
</div>
</div>
<a id="a39dd434250d655456533847e0fd24550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dd434250d655456533847e0fd24550">&#9670;&nbsp;</a></span>make_elliptic_ipdg_dirichlet_vector_functional() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6b60716df2a7ff51cc279cefd611be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b60716df2a7ff51cc279cefd611be4">&#9670;&nbsp;</a></span>make_elliptic_ipdg_dirichlet_vector_functional() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a0e7e5137ef012766008a318adffd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0e7e5137ef012766008a318adffd50">&#9670;&nbsp;</a></span>make_elliptic_ipdg_dirichlet_vector_functional() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d7ac26de7ce19c933a4961092550982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7ac26de7ce19c933a4961092550982">&#9670;&nbsp;</a></span>make_elliptic_ipdg_dirichlet_vector_functional() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionFactorType , class DiffusionTensorType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0abcf8a0c7289b894ad73c92ec1aa235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abcf8a0c7289b894ad73c92ec1aa235">&#9670;&nbsp;</a></span>make_elliptic_ipdg_dirichlet_vector_functional() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DirichletType , class DiffusionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DirichletType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01046.html">EllipticIpdgDirichletVectorFunctional</a>&lt;DirichletType, DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, VectorType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_dirichlet_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const DirichletType &amp;&#160;</td>
          <td class="paramname"><em>dirichlet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe374821da426a5bab4966631dfb33be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe374821da426a5bab4966631dfb33be">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor, tensor, boundary_info, space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a723ae048998935420493a23ee5ea991e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723ae048998935420493a23ee5ea991e">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                              tensor,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a27716e9a50252e78dfbd00882f043510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27716e9a50252e78dfbd00882f043510">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor, tensor, boundary_info, space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a731877def65722027447923a18bfe442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731877def65722027447923a18bfe442">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                              tensor,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              space,</div><div class="line">                                                                                              grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad0020b01053f44190ce800c02c652c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0020b01053f44190ce800c02c652c4d">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(factor,</div><div class="line">                                                         tensor,</div><div class="line">                                                         boundary_info,</div><div class="line">                                                         range_space,</div><div class="line">                                                         source_space,</div><div class="line">                                                         grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aaa5d861f8a59da22b6c952478fe8a3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5d861f8a59da22b6c952478fe8a3ff">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                              tensor,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              range_space,</div><div class="line">                                                                                              source_space,</div><div class="line">                                                                                              grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae48a8f11e994cb65b886bfd653202a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48a8f11e994cb65b886bfd653202a76">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="aa185548adae9af94131880d62bbabc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa185548adae9af94131880d62bbabc7e">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                  tensor,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad88e606467a37be4814415340f0e730c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88e606467a37be4814415340f0e730c">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space). </p>

</div>
</div>
<a id="aa50f1b52002d4f069041329ad968ebc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f1b52002d4f069041329ad968ebc8">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                  tensor,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  space,</div><div class="line">                                                                                  grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a11326936be89261963fcc56f41c15462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11326936be89261963fcc56f41c15462">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used). </p>

</div>
</div>
<a id="a8ef7bbeba344f2badd87c6eb96677e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef7bbeba344f2badd87c6eb96677e3b">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(factor,</div><div class="line">                                                                                  tensor,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  range_space,</div><div class="line">                                                                                  source_space,</div><div class="line">                                                                                  grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac1687b0deb307fedd89aa3ce0420443f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1687b0deb307fedd89aa3ce0420443f">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion, boundary_info, space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a244d38839d3e1f19883cdd2b1dd07f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244d38839d3e1f19883cdd2b1dd07f3c">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5d7d95d7700b45a8690ba2bc6a8bb020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7d95d7700b45a8690ba2bc6a8bb020">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion, boundary_info, space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a0e1154218ae80f409ab597655b27e3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1154218ae80f409ab597655b27e3ec">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              space,</div><div class="line">                                                                                              grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2fe0640b34f33baafaadb61e440d80a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe0640b34f33baafaadb61e440d80a2">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, default IPDG method is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType&gt;(diffusion,</div><div class="line">                                                         boundary_info,</div><div class="line">                                                         range_space,</div><div class="line">                                                         source_space,</div><div class="line">                                                         grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac305bd91061a17898645ef78e47ad11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac305bd91061a17898645ef78e47ad11f">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (MatrixType has to be supllied, a matrix is created automatically, IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType and IPDG method have to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;MatrixType, LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                              boundary_info,</div><div class="line">                                                                                              range_space,</div><div class="line">                                                                                              source_space,</div><div class="line">                                                                                              grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5a19aae1548e2aaa5c4ad71b6a72466a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a19aae1548e2aaa5c4ad71b6a72466a">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="aa819bbf4e4799bf4501031a635645b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819bbf4e4799bf4501031a635645b40">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; typename SpaceType::GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4ccb6c2d56014a31dfa7f96fc6358919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccb6c2d56014a31dfa7f96fc6358919">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used, source and range space are given by space). </p>

</div>
</div>
<a id="a1f5008a3fbbd914460f557f656d83328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5008a3fbbd914460f557f656d83328">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, method, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  space,</div><div class="line">                                                                                  grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a26a1a51d0e80b2681d20c0f1b5b8bd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a1a51d0e80b2681d20c0f1b5b8bd94">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, <a class="el" href="a00233.html#a6f1c29074ab80702c5e50abbdb5ba4b8">LocalEllipticIpdgIntegrands::default_method</a>, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (default IPDG method is used). </p>

</div>
</div>
<a id="a1f8f8f71e1f1d2e056507159a06a4dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8f8f71e1f1d2e056507159a06a4dad">&#9670;&nbsp;</a></span>make_elliptic_ipdg_matrix_operator() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;LocalEllipticIpdgIntegrands::Method method, class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01806.html">EllipticIpdgMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, method, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_ipdg_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix IPDG operator (IPDG method has to be supplied). </p>
<dl class="section note"><dt>Note</dt><dd>IPDG method has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_ipdg_matrix_operator&lt;LocalEllipticIpdgIntegrands::swipdg&gt;(diffusion,</div><div class="line">                                                                                  boundary_info,</div><div class="line">                                                                                  matrix,</div><div class="line">                                                                                  range_space,</div><div class="line">                                                                                  source_space,</div><div class="line">                                                                                  grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abd4bc8e7face047ca003488d5fa49222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4bc8e7face047ca003488d5fa49222">&#9670;&nbsp;</a></span>make_elliptic_localizable_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01810.html">EllipticLocalizableProduct</a>&lt;DiffusionType, void, GridLayerType, RangeType, SourceType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01810.html">EllipticLocalizableProduct</a>, especially for the role of diffusion. </dd></dl>

</div>
</div>
<a id="a3e0540718ef11a506fc7460414061113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0540718ef11a506fc7460414061113">&#9670;&nbsp;</a></span>make_elliptic_localizable_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01810.html">EllipticLocalizableProduct</a>&lt;DiffusionFactorType, DiffusionTensorType, GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a01810.html">EllipticLocalizableProduct</a>, especially for the role of diffusion_factor and diffusion_tensor. </dd></dl>

</div>
</div>
<a id="a8e5ac11789f5a6a20eb9c4c591f7590f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5ac11789f5a6a20eb9c4c591f7590f">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std:: unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa2b417cfe37ddd413a1a88f8d4832b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b417cfe37ddd413a1a88f8d4832b7d">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad4e8de41cd99705c54a463ff8979abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e8de41cd99705c54a463ff8979abb4">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionFactorType , class DiffusionTensorType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(factor, tensor, range_space, source_space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac79ebd71eca30efd87b6f57c0f49f600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79ebd71eca30efd87b6f57c0f49f600">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std:: unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;:: type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="a6f78e3513c8c8445e9b7065419041030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f78e3513c8c8445e9b7065419041030">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (source and range space are given by space). </p>

</div>
</div>
<a id="ad4f6e182a9cecb5d8c8f9bb6da507e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f6e182a9cecb5d8c8f9bb6da507e36">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionFactorType , class DiffusionTensorType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator. </p>

</div>
</div>
<a id="a645898ad9e18b9ee082694eb129be6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645898ad9e18b9ee082694eb129be6e5">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a59f7a9e88dc8fb3ea1bc7b5847d148e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f7a9e88dc8fb3ea1bc7b5847d148e2">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab1b492fe167180d66b57155a9c4efc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b492fe167180d66b57155a9c4efc20">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class DiffusionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_elliptic_matrix_operator&lt; MatrixType &gt;(diffusion, range_space, source_space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4b224a5d8038ccad232f22cd4f94392c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b224a5d8038ccad232f22cd4f94392c">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="ad25dd39c95e458ac83ee12b6f50b105d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25dd39c95e458ac83ee12b6f50b105d">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given, source and range space are given by space). </p>

</div>
</div>
<a id="a4b601eea0442b605302ad79f18056d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b601eea0442b605302ad79f18056d87">&#9670;&nbsp;</a></span>make_elliptic_matrix_operator() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiffusionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01814.html">EllipticMatrixOperator</a>&lt;DiffusionType, void, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an elliptic matrix operator (single diffusion given). </p>

</div>
</div>
<a id="a6d25b2d08b99737792191ea9dc56b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d25b2d08b99737792191ea9dc56b529">&#9670;&nbsp;</a></span>make_elliptic_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class DiffusionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01818.html">EllipticOperator</a>&lt;DiffusionType, void, GridLayerType, typename DiffusionType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionType &amp;&#160;</td>
          <td class="paramname"><em>diffusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1757fab0086f1e2e9767645fc23fd9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1757fab0086f1e2e9767645fc23fd9c5">&#9670;&nbsp;</a></span>make_elliptic_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class DiffusionFactorType , class DiffusionTensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionFactorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;DiffusionTensorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01818.html">EllipticOperator</a>&lt;DiffusionFactorType, DiffusionTensorType, GridLayerType, typename DiffusionFactorType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_elliptic_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionFactorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiffusionTensorType &amp;&#160;</td>
          <td class="paramname"><em>diffusion_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bd5ee218bea07115ecafce8f0d24a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd5ee218bea07115ecafce8f0d24a65">&#9670;&nbsp;</a></span>make_fv_space() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , size_t r, size_t rC, class GL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02534.html">FvSpace</a>&lt;GL, R, r, rC&gt; Dune::GDT::make_fv_space </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afefce99b2e71a9fe2b8ba379beeb268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefce99b2e71a9fe2b8ba379beeb268d">&#9670;&nbsp;</a></span>make_fv_space() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , size_t r, class GL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02534.html">FvSpace</a>&lt;GL, R, r, 1&gt; Dune::GDT::make_fv_space </td>
          <td>(</td>
          <td class="paramtype">const GL &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6adbf86b5d86a023e2e8e93cbcbc6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6adbf86b5d86a023e2e8e93cbcbc6d5">&#9670;&nbsp;</a></span>make_global_l2_projection_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02178.html">L2GlobalProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada5f8915864e0699caf07017b3f0bbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5f8915864e0699caf07017b3f0bbd9">&#9670;&nbsp;</a></span>make_global_l2_projection_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02178.html">L2GlobalProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc211dfec7d3c46b5d59c7b1403bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc211dfec7d3c46b5d59c7b1403bdf5">&#9670;&nbsp;</a></span>make_global_l2_projection_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02170.html">L2GlobalProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_global_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb9ec66c9a827b012b33a1d458d58292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9ec66c9a827b012b33a1d458d58292">&#9670;&nbsp;</a></span>make_global_l2_prolongation_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02262.html">L2GlobalProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_global_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9772649b7272d7feee16e3cc0057d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9772649b7272d7feee16e3cc0057d4a2">&#9670;&nbsp;</a></span>make_global_l2_prolongation_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02262.html">L2GlobalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_global_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a564a3610e71d59f474af2dfd988fc868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564a3610e71d59f474af2dfd988fc868">&#9670;&nbsp;</a></span>make_global_l2_prolongation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02254.html">L2GlobalProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_global_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad13b49c6523f019648edfa58bd969a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13b49c6523f019648edfa58bd969a01">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89d3d1d139a3701a04009dd8f4f1b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d3d1d139a3701a04009dd8f4f1b45">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ea2165b905a0ab10151dc18ed738a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea2165b905a0ab10151dc18ed738a2d">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f4d4bd089dc21a0aa4b6c1ca31147cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4d4bd089dc21a0aa4b6c1ca31147cb">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa88a95427edfbc6c6b5c870231eaad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88a95427edfbc6c6b5c870231eaad13">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36902d54169c4fe3b79ed285b09bfe02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36902d54169c4fe3b79ed285b09bfe02">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaeb52cbd5b060759f9de394e39eab0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb52cbd5b060759f9de394e39eab0f4">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27a02f887f4a3f3a70d9345e06985b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a02f887f4a3f3a70d9345e06985b7a">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3641c0872fda34a50acf5d8e239b7255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3641c0872fda34a50acf5d8e239b7255">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a531cfd940b7c4bee0e93c711b84b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a531cfd940b7c4bee0e93c711b84b23">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d1e7607ac4a7de8b39221a64f6a8911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1e7607ac4a7de8b39221a64f6a8911">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab74f9b73968b13fde92ca858e2580c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74f9b73968b13fde92ca858e2580c8a">&#9670;&nbsp;</a></span>make_l2_face_vector_functional() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01058.html">L2FaceVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_face_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::ApplyOn::WhichIntersection&lt; GridLayerType &gt; *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a3a68504ab32dceaf20a367e2617b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3a68504ab32dceaf20a367e2617b58">&#9670;&nbsp;</a></span>make_l2_localizable_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02022.html">L2LocalizableProduct</a>&lt;GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_l2_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02022.html">L2LocalizableProduct</a> </dd></dl>

</div>
</div>
<a id="aa6df3ece6d2703ff6bedf3420c5e3a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6df3ece6d2703ff6bedf3420c5e3a95">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4a19320cc6468677248b8ab4eed3b3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a19320cc6468677248b8ab4eed3b3de">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a59bd3e4a730d2e05605abbee7bcd9baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bd3e4a730d2e05605abbee7bcd9baf">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;:: type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_l2_matrix_operator&lt; MatrixType &gt;(range_space, source_space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aaca65e541579ace42958d0248e85dc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca65e541579ace42958d0248e85dc8e">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="a3aa7d90d3f800e69ceb9956818a7ab29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa7d90d3f800e69ceb9956818a7ab29">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator (source and range space are given by space). </p>

</div>
</div>
<a id="aa8805736f27ea9f91b346e93251ffcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8805736f27ea9f91b346e93251ffcaf">&#9670;&nbsp;</a></span>make_l2_matrix_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02030.html">L2MatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;:: type Dune::GDT::make_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an L2 matrix operator. </p>

</div>
</div>
<a id="aaa8d9d3c704dad52fe1215c40ce7755e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8d9d3c704dad52fe1215c40ce7755e">&#9670;&nbsp;</a></span>make_l2_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02038.html">L2Operator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb37c26aebc4f0de53587319f55a017b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb37c26aebc4f0de53587319f55a017b">&#9670;&nbsp;</a></span>make_l2_projection_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02230.html">L2ProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1fda08c8477972bb5135da2513518dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fda08c8477972bb5135da2513518dc">&#9670;&nbsp;</a></span>make_l2_projection_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02230.html">L2ProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53207d499f1a26958db4d5efb6ba6bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53207d499f1a26958db4d5efb6ba6bdb">&#9670;&nbsp;</a></span>make_l2_projection_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02210.html">L2ProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa746df909339503f60a17661285bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa746df909339503f60a17661285bc4">&#9670;&nbsp;</a></span>make_l2_prolongation_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02298.html">L2ProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SS, SV&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RS, RV&gt; &gt; &gt; &gt;::type Dune::GDT::make_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0091fab2708f1a388b30a247166ae55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0091fab2708f1a388b30a247166ae55c">&#9670;&nbsp;</a></span>make_l2_prolongation_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a02298.html">L2ProlongationLocalizableOperator</a>&lt;typename RS::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SS, SV&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RS, RV&gt; &gt; &gt; Dune::GDT::make_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f74bd1b2248a25d0c380d3464f4724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f74bd1b2248a25d0c380d3464f4724">&#9670;&nbsp;</a></span>make_l2_prolongation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02278.html">L2ProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe8c4f6526fc7650a166503429052bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8c4f6526fc7650a166503429052bd3">&#9670;&nbsp;</a></span>make_l2_volume_vector_functional() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4789d283e11ff2337c91378c073139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4789d283e11ff2337c91378c073139d">&#9670;&nbsp;</a></span>make_l2_volume_vector_functional() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType , class FunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac41f06438b689a0443f35c3fb314021c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41f06438b689a0443f35c3fb314021c">&#9670;&nbsp;</a></span>make_l2_volume_vector_functional() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5efe5fd8a990d2670302e0454aec822f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efe5fd8a990d2670302e0454aec822f">&#9670;&nbsp;</a></span>make_l2_volume_vector_functional() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class VectorType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;FunctionType&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a01054.html">L2VolumeVectorFunctional</a>&lt;FunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_l2_volume_vector_functional </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d5160a18176f922670606c9fabaaeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5160a18176f922670606c9fabaaeed">&#9670;&nbsp;</a></span>make_lagrange_projection_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02242.html">LagrangeProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80017c8590156bbc14e3b5809d9b5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80017c8590156bbc14e3b5809d9b5706">&#9670;&nbsp;</a></span>make_lagrange_projection_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02242.html">LagrangeProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bd9942fa032bb572db38180e9602c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd9942fa032bb572db38180e9602c4e">&#9670;&nbsp;</a></span>make_lagrange_projection_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02246.html">LagrangeProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_lagrange_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ff7e797cda0076652379f9a8c2b5c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff7e797cda0076652379f9a8c2b5c16">&#9670;&nbsp;</a></span>make_lagrange_prolongation_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02318.html">LagrangeProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_lagrange_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa322e33210fa15e3b02471f4f9250b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa322e33210fa15e3b02471f4f9250b5e">&#9670;&nbsp;</a></span>make_lagrange_prolongation_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a02318.html">LagrangeProlongationLocalizableOperator</a>&lt;typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; Dune::GDT::make_lagrange_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39a31d2d051596296e00ceea186232b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39a31d2d051596296e00ceea186232b">&#9670;&nbsp;</a></span>make_lagrange_prolongation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02310.html">LagrangeProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_lagrange_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7129f2ce7fb2ad7bb8403d0e2378e1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7129f2ce7fb2ad7bb8403d0e2378e1d1">&#9670;&nbsp;</a></span>make_laplace_localizable_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02046.html">LaplaceLocalizableProduct</a>&lt;GridLayerType, RangeType, SourceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02046.html">LaplaceLocalizableProduct</a> </dd></dl>

</div>
</div>
<a id="ac58267637036be6ee37f0e48d1162ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58267637036be6ee37f0e48d1162ab0">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab45e793f951853fe2462720fbdb0efe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e793f951853fe2462720fbdb0efe2">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a187c2435913bbaefd577916a044eeaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c2435913bbaefd577916a044eeaff">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_laplace_matrix_operator&lt; MatrixType &gt;(range_space, source_space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a73a1412fbe2dd31bb9c7c48f943fecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a1412fbe2dd31bb9c7c48f943fecb8">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="aa2f40f54739e0f5758158c62af274630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f40f54739e0f5758158c62af274630">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator (source and range space are given by space). </p>

</div>
</div>
<a id="a5bfd627da92f1aa70984f784203f0f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfd627da92f1aa70984f784203f0f57">&#9670;&nbsp;</a></span>make_laplace_matrix_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02054.html">LaplaceMatrixOperator</a>&lt;RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_laplace_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Laplace matrix operator. </p>

</div>
</div>
<a id="a614c77184eaff56d640da03fc408d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614c77184eaff56d640da03fc408d27b">&#9670;&nbsp;</a></span>make_laplace_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02062.html">LaplaceOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_laplace_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1612b90648aab6894d91e094dbba596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1612b90648aab6894d91e094dbba596">&#9670;&nbsp;</a></span>make_local_l2_projection_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02198.html">L2LocalProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5983630b75ef508253bcbf202327c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5983630b75ef508253bcbf202327c73">&#9670;&nbsp;</a></span>make_local_l2_projection_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02198.html">L2LocalProjectionLocalizableOperator</a>&lt;typename SpaceType::GridLayerType, SourceType, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72af8b84996d16c4b31bbceaceefca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72af8b84996d16c4b31bbceaceefca6f">&#9670;&nbsp;</a></span>make_local_l2_projection_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02190.html">L2LocalProjectionOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_local_l2_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5a54eebb2c635b8f582ad3e43941b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a54eebb2c635b8f582ad3e43941b14">&#9670;&nbsp;</a></span>make_local_l2_prolongation_localizable_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02274.html">L2LocalProlongationLocalizableOperator</a>&lt;GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;:: type Dune::GDT::make_local_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b90a04cecdb9a4caa0dc6d876c0b0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b90a04cecdb9a4caa0dc6d876c0b0d1">&#9670;&nbsp;</a></span>make_local_l2_prolongation_localizable_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;SourceVectorType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; XT::LA::is_vector&lt;RangeVectorType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02274.html">L2LocalProlongationLocalizableOperator</a>&lt; typename RangeSpaceType::GridLayerType, <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt;SourceSpaceType, SourceVectorType&gt;, <a class="el" href="a00922.html">DiscreteFunction</a>&lt;RangeSpaceType, RangeVectorType&gt; &gt; &gt; &gt;::type Dune::GDT::make_local_l2_prolongation_localizable_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae259c74e23bd82ed2bdb7bc190df8093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae259c74e23bd82ed2bdb7bc190df8093">&#9670;&nbsp;</a></span>make_local_l2_prolongation_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02266.html">L2LocalProlongationOperator</a>&lt;GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_local_l2_prolongation_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f639f3b2734291a3ab3c17c8894fdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f639f3b2734291a3ab3c17c8894fdcb">&#9670;&nbsp;</a></span>make_localizable_dirichlet_projection_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class RangeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a02166.html">DirichletProjectionLocalizableOperator</a>&lt;GridLayerType, SourceType, RangeType&gt; &gt; Dune::GDT::make_localizable_dirichlet_projection_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Grid::BoundaryInfo&lt; XT::Grid::extract_intersection_t&lt; GridLayerType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8eb42db46ca6c5872fde464ac03a2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8eb42db46ca6c5872fde464ac03a2b2">&#9670;&nbsp;</a></span>make_weighted_l2_localizable_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class GridLayerType , class RangeType , class SourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;RangeType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02078.html">WeightedL2LocalizableProduct</a>&lt;WeightFunctionType, GridLayerType, RangeType, SourceType&gt; &gt; &gt;:: type Dune::GDT::make_weighted_l2_localizable_product </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02078.html">WeightedL2LocalizableProduct</a> </dd></dl>

</div>
</div>
<a id="a94c370bc5da752091bf363382ccad66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c370bc5da752091bf363382ccad66f">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space, grid_layer of the space is used). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, space);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a419d49e35616d30a21a82601a8358d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d49e35616d30a21a82601a8358d85">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically, source and range space are given by space). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8790f22db7ca14a73ae19e9993742320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8790f22db7ca14a73ae19e9993742320">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , class WeightFunctionType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (MatrixType has to be supllied, a matrix is created automatically). </p>
<dl class="section note"><dt>Note</dt><dd>MatrixType has to be supplied, i.e., use like <div class="fragment"><div class="line"><span class="keyword">auto</span> op = make_weighted_l2_matrix_operator&lt; MatrixType &gt;(weight, range_space, source_space, grid_layer);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6c65510f0494c44231137be7b61eb712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c65510f0494c44231137be7b61eb712">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class SpaceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (source and range space are given by space, grid_layer of the space is used). </p>

</div>
</div>
<a id="a7fa80f01415bd014fdc5dd79dd286edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa80f01415bd014fdc5dd79dd286edc">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class SpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, MatrixType, GridLayerType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator (source and range space are given by space). </p>

</div>
</div>
<a id="af9ae6d54b1de546de981980dcc26c961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ae6d54b1de546de981980dcc26c961">&#9670;&nbsp;</a></span>make_weighted_l2_matrix_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class WeightFunctionType , class MatrixType , class RangeSpaceType , class SourceSpaceType , class GridLayerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::LA::is_matrix&lt;MatrixType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;RangeSpaceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;SourceSpaceType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02082.html">WeightedL2MatrixOperator</a>&lt;WeightFunctionType, RangeSpaceType, MatrixType, GridLayerType, SourceSpaceType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_matrix_operator </td>
          <td>(</td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeSpaceType &amp;&#160;</td>
          <td class="paramname"><em>range_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceSpaceType &amp;&#160;</td>
          <td class="paramname"><em>source_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a weighted L2 matrix operator. </p>

</div>
</div>
<a id="ac54f2e7c92b7268e11b82ccea2407271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54f2e7c92b7268e11b82ccea2407271">&#9670;&nbsp;</a></span>make_weighted_l2_operator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class WeightFunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;WeightFunctionType&gt;::value &amp;&amp; XT::Grid::is_layer&lt;GridLayerType&gt;::value, std::unique_ptr&lt;<a class="el" href="a02086.html">WeightedL2Operator</a>&lt;WeightFunctionType, GridLayerType, typename WeightFunctionType::RangeFieldType&gt; &gt; &gt;::type Dune::GDT::make_weighted_l2_operator </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4435bc1a91769f295e13244775d9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4435bc1a91769f295e13244775d9366">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::GDT::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01110.html">ConstLocalDoFVector</a>&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab28f3c4b54b4fb8206d8b24f2f2c1e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28f3c4b54b4fb8206d8b24f2f2c1e32">&#9670;&nbsp;</a></span>project() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03030.html">is_cg_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6930f61566d99bf1e2ad1a1ea8ebdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6930f61566d99bf1e2ad1a1ea8ebdda">&#9670;&nbsp;</a></span>project() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; !<a class="el" href="a03030.html">is_cg_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2246f50ebf840a99127b39c957faadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2246f50ebf840a99127b39c957faadf">&#9670;&nbsp;</a></span>project() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03030.html">is_cg_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add15cc27cd3d12bd7a1e30e5bf37224f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add15cc27cd3d12bd7a1e30e5bf37224f">&#9670;&nbsp;</a></span>project() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; !<a class="el" href="a03030.html">is_cg_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a739fd9a05d811357d4e054e61017b4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739fd9a05d811357d4e054e61017b4be">&#9670;&nbsp;</a></span>project_l2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_l2 </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce48b8d05bd6a7e3c9f4fb215eb0b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce48b8d05bd6a7e3c9f4fb215eb0b93">&#9670;&nbsp;</a></span>project_l2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_l2 </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48d76b5da36129c1d49c8e677e830218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d76b5da36129c1d49c8e677e830218">&#9670;&nbsp;</a></span>project_lagrange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_lagrange </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abda2ed2cfc25f129a952054c203923a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda2ed2cfc25f129a952054c203923a3">&#9670;&nbsp;</a></span>project_lagrange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceType , class SpaceType , class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Functions::is_localizable_function&lt;SourceType&gt;::value &amp;&amp; <a class="el" href="a03006.html">is_space</a>&lt;<a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>&gt;::value &amp;&amp; XT::LA::is_vector&lt;VectorType&gt;::value, void&gt;::type Dune::GDT::project_lagrange </td>
          <td>(</td>
          <td class="paramtype">const SourceType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a00231.html#a1dc558b2ff4b8e95434d41c4e51f6b92">SpaceType</a>, VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa08c25274fd4dd387590da5f9087f4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08c25274fd4dd387590da5f9087f4ea">&#9670;&nbsp;</a></span>prolong() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; <a class="el" href="a03030.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af392b611b527d3309b23f902cae6bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af392b611b527d3309b23f902cae6bf4b">&#9670;&nbsp;</a></span>prolong() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value &amp;&amp; !<a class="el" href="a03030.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b3045aa4dc67c8c6aa40604468a8ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3045aa4dc67c8c6aa40604468a8ec7">&#9670;&nbsp;</a></span>prolong() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="a03030.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a857b2b6325e4bf58234495716f241819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857b2b6325e4bf58234495716f241819">&#9670;&nbsp;</a></span>prolong() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="a03030.html">is_cg_space</a>&lt;RangeSpaceType&gt;::value, void&gt;::type Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RangeSpaceType, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa033d6900fdcffdafedd4d950267819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa033d6900fdcffdafedd4d950267819e">&#9670;&nbsp;</a></span>prolong() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SourceSpaceType , class SourceVectorType , class RangeSpaceType , class RangeVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::GDT::prolong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SourceSpaceType, SourceVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; <a class="el" href="a02102.html">BlockSpace</a>&lt; RangeSpaceType &gt;, RangeVectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fab99cb387849e714c05a0d2b27c197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fab99cb387849e714c05a0d2b27c197">&#9670;&nbsp;</a></span>prolong_l2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, void&gt;::type Dune::GDT::prolong_l2 </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a961b32a7982c5bf781045fbfa0eb9aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961b32a7982c5bf781045fbfa0eb9aab">&#9670;&nbsp;</a></span>prolong_l2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::GDT::prolong_l2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>over_integrate</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a83a245e10e4fe1a2ae4006d0527c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a83a245e10e4fe1a2ae4006d0527c89">&#9670;&nbsp;</a></span>prolong_lagrange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GridLayerType , class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;XT::Grid::is_layer&lt;GridLayerType&gt;::value, void&gt;::type Dune::GDT::prolong_lagrange </td>
          <td>(</td>
          <td class="paramtype">const GridLayerType &amp;&#160;</td>
          <td class="paramname"><em>grid_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b9b021f5197437b7c25d50a86c0a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b9b021f5197437b7c25d50a86c0a72">&#9670;&nbsp;</a></span>prolong_lagrange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SS , class SV , class RS , class RV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::GDT::prolong_lagrange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00890.html">ConstDiscreteFunction</a>&lt; SS, SV &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00922.html">DiscreteFunction</a>&lt; RS, RV &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XT::Common::Parameter &amp;&#160;</td>
          <td class="paramname"><em>param</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac2cc306d857c4fc4efcd11b712f67eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cc306d857c4fc4efcd11b712f67eb2">&#9670;&nbsp;</a></span>backend_names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const XT::Common::FixedMap&lt;<a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a>, std::string, 1&gt; Dune::GDT::backend_names = {{<a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a>, &quot;gdt&quot;}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37fb8b6a35c3b20bf579f814239315ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fb8b6a35c3b20bf579f814239315ae">&#9670;&nbsp;</a></span>default_cg_backend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_cg_backend = <a class="el" href="a00231.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f51ae51b9d4e6763745a95fe0e52d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f51ae51b9d4e6763745a95fe0e52d8">&#9670;&nbsp;</a></span>default_dg_backend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_dg_backend = <a class="el" href="a00231.html#a486607c0fc12b5da5bc46c20300b6dae">default_space_backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a486607c0fc12b5da5bc46c20300b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486607c0fc12b5da5bc46c20300b6dae">&#9670;&nbsp;</a></span>default_space_backend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045">Backends</a> Dune::GDT::default_space_backend = <a class="el" href="a00231.html#afd9e79bf2e05d76e877c835fa352f045a0bef679c27a1c77dd1f1dfd3c591894b">Backends::gdt</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e5609284c505b10ffff369ba619308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5609284c505b10ffff369ba619308">&#9670;&nbsp;</a></span>unit_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatrixType , size_t size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;const MatrixType&gt; Dune::GDT::unit_matrix = std::make_unique&lt;MatrixType&gt;(XT::LA::eye_matrix&lt;MatrixType&gt;(size, size))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
